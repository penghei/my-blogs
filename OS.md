---
title: 操作系统知识点总结
date: 2022-05-12 15:58:22
tags: 日常学习
categories: 原理
cover:
---

# 进程和线程

## 进程出现的原因

程序不能进行并发，但操作系统需要一次执行多个任务来提升效率。
进程有着比程序更高的灵活性和可控性。比如进程可以被挂起（阻塞），cpu 可以通过调度多个进程的先后执行来使得不同任务并发执行，而这对于程序来说是不可能的，很难在执行一段程序期间中断去执行另一段

## 进程

### 进程的定义

1. 进程是程序的一次执行。
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
3. 进程是程序在一个数据集合上运行的过程，它是**系统进行资源分配和调度的一个独立单位**。

### 进程的组成

为使程序（含数据）能独立运行，应为之配置一个进程控制块，即 PCB(Process Control Block)；

由程序段、数据段和 PCB 三部分便构成了进程实体。

- 程序段：即进程中包含的代码部分
- 数据段：进程存储的数据资源
- PCB：进程控制块，负责进程的管理、标识、调度

#### PCB

PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

PCB 主要包含的信息：

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；
- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；
- 资源分配清单：有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
- CPU 相关信息：CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

PCB 是通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。

### 进程的特点

1. 动态性：进程的实质是进程实体的一次执行过程，因此，动态性是进程的**最基本的特征**。 动态性表现为：由创建而产生，由调度而执行，由撤消而消亡。可见，进程实体有一定的生命期。
2. 并发性：多个进程实体同存于内存中，且能在一段时间内同时运行。

> 并发和并行的区别：
> 并发是某一刻只有一个任务在进行，但是某个很短的时间段内任务交替执行，看起来就像是在并行
> 并行是真正的并发执行，需要多核处理器

3. 独立性：指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位；
4. 异步性：指进程按各自独立的、不可预知的速度向前推进，或说进程实体按异步方式运行。

### 进程的状态

#### 三种基本状态

![](https://pic.imgdb.cn/item/627ccbcf0947543129f6e146.jpg)

- 就绪状态（Ready）：当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。
- 执行状态(Running)：进程已获得 CPU，其程序正在执行。
- 阻塞状态(Blocked)：正在执行的进程由于发生某事件而暂时无法继续执行时，当前进程被暂停，cpu 转去执行其他进程或其他任务，把这种暂停状态称为阻塞状态，有时也称为等待状态。

#### 五种完整状态

其实就是在三种基本状态上引入创建和结束状态

![](https://pic1.imgdb.cn/item/63626d8d16f2c2beb114fec7.jpg)

- NULL -> 创建状态：一个新进程被创建时的第一个状态；
- 创建状态 -> 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- 运行状态 -> 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理；

#### 引入挂起状态

如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，所以在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。

**进程没有占用实际物理内存的状态，就叫做挂起状态**。

![](https://pic1.imgdb.cn/item/63626e1516f2c2beb115db7a.jpg)

进入挂起状态不一定是系统的调配，还可以是用户的控制。比如调用 sleep 让进程挂起。

### 进程的调度

在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。

根据如何处理时钟中断 ，把调度算法分为两类：

- 非抢占式调度：算法挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- 抢占式调度：算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。

#### 调度算法

常见的调度算法：

1. 先来先服务调度算法 FCFS：每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。
2. 最短作业优先调度算法 SJF：优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。
3. 时间片轮转调度算法 RR：每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；
4. 最高优先级调度算法 HPF：引入了优先级的概念，每次选择优先级最高的先运行，优先级有动态（确定就不再改变）和静态之分，该算法也有抢占和非抢占两种

### 进程通信

进程通信的手段：

1. 管道：管道传输数据是单向的，类似于一个 FIFO 队列，当数据量非常大时效率很低，不适合进程间频繁地交换数据
2. 消息队列：消息队列是保存在内核中的消息链表，基本单位是“消息”，是用户自定义的数据类型，发送方和接收方要提前约定好消息的类型、大小等。每个消息体都是固定大小的存储块。消息队列机制不足的地方在于通信有延时，并且传输的数据量不能太大
3. 共享内存：共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中；这样这个进程写入的东西，另外一个进程马上就能看到。
4. 信号量：本质上是一个计数器，常用于实现进程的同步，并非缓存数据。信号量常见的操作是 P/V 操作，即减少/增加信号量，相当于申请/释放资源
4. 信号：表示进程之间发送一种信号。不等同于信号量，而是直接由某个进程向另一个进程发送，另一个进程接收后执行约定好的操作。信号机制是通信中唯一的异步机制
4. socket：主机之间的通信手段，即TCP和UDP采用的方式。

### 进程同步

为了使进程之间能更好地相互合作，操作系统引入了两种主要的进程间关系：互斥和同步
- 互斥：指多个进程访问同一个临界资源时，一次只能有一个进程访问该资源，当有一个进程访问时排斥掉其他任何进程的访问。也就说保证一个进程在临界区执行时，其他进程应该被阻止进入临界区
- 同步：并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。

进程同步的主要任务：是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。

同步可以理解为调整不同进程之间的执行顺序，使他们能更好地共享资源和共同协作。注意这是两点

同步机制应遵循的规则

1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

#### 同步的方式

进程的同步主要可以通过两种方式实现：

1. 同步锁机制，即一个进程访问临界资源时申请到一个 🔒，必须持有这个 🔒 才能访问，因此会排斥其他的线程。
    🔒的形式有两种：
    - 一种是忙等待🔒，即当进程申请不到锁时持续通过while循环阻塞，直到申请到锁为止；
    - 一种是非忙等待，即当进程申请锁申请不到时，将该进程放入改资源的等待队列中，当该进程的锁被释放，就取出等待队列的进程执行。
2. 信号量（sem）机制，即信号量表示资源的数量，通过 PV 操作控制。每个进程访问临界资源时必须先通过 P 操作减少一个信号量，访问完毕时再通过 V 操作释放信号量；当信号量<0 时就必须等待信号量释放才可以进入。

- P 操作：将 sem 减 1，相减后，如果 sem < 0，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；
- V 操作：将 sem 加 1，相加后，如果 sem <= 0，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；


#### 基本概念

1. 临界资源：一次仅允许一个进程访问的资源为临界资源。
2. 临界区：把在每个进程中访问临界资源的那段代码称为临界区。
3. 信号量机制；信号量即一类临界资源，用于表示资源的数目，通常只能通过 wait 和 signal 操作进行减少和增加

#### 生产者消费者问题

基本原理：通过信号量实现互斥。需要三个信号量，分别是：

- 互斥信号量 mutex：用于互斥访问缓冲区，初始化值为 1；
- 资源信号量 full：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
- 资源信号量 empty：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；

伪代码如下：

```C
semaphore mutex=1;
semaphore full=0; // 表示满位的数量（已经放入的资源的数量）
semaphore empty=N; // 表示空位的数量（初始为缓冲区的大小）

void producer( ) {
    while (1) {
        wait(empty) // 将空位数量-1，如果没有空位就不会执行
        wait(mutex)
        // 生产一个数据
        signal(mutex);
        signal(full) // 将满位数量+1
    }
}

void consumer ( ) {
    while (1) {
        wait(full) // 将满位数量-1
        wait(mutex);
        // 取走一个数据
        signal(mutex);
        signal(empty) // 将空位数量+1
    }
}

void main(){
    cobegin // 同时启动两个进程
    producer(); consumer();
    coend
}
```

#### 哲学家进餐问题

![](https://pic.imgdb.cn/item/627cd07709475431290594ce.jpg)

问题描述：五个哲学家坐在一张桌子旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌上有五碗意大利面，每位哲学家之间各有一只餐叉，假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。
问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。

哲学家进餐问题的关键是，如果每个哲学家都拿起自一边的叉子，那么每个人都会等待另一边的叉子，从而无限等待下去，就造成了死锁。


方案一：规定奇数号的哲学家先拿左边的，再拿右边的；偶数号的哲学家相反。当然反过来也可以，目的就是保证相邻的哲学家不会同时申请左边或申请右边。
如果一个奇数位的哲学家没有拿起左边的叉子，那他也不会拿起右边的，而是阻塞在第一步直到拿起左边的叉子为止；
如果这个奇数位的哲学家拿起了左边的叉子，那他就会等待右边的叉子，并且它现在是在“持有左边叉子”的状态，其他人不能用它左边的叉子。

在这种情况下，5个人的哲学家只能有最多两个人同时用餐。

![](https://pic1.imgdb.cn/item/6367413516f2c2beb1d648f3.jpg)

![](https://pic1.imgdb.cn/item/63673f5f16f2c2beb1d365cf.jpg)


方案二：需要一种S操作，这种操作不同于普通的PV，它可以同时考虑两个信号量，当两个信号量都满足时才会继续。
因此可以规定哲学家只有同时获取到自己左边和右边的叉子才能用餐：

```C
semaphore chopstick[5]={1,1,1,1,1};
do{
    // think;
    Sswait(chopstick[(i+1) % 5],chopstick[i]);
    // eat；
    Ssignal(chopstick[(i+1) % 5],chopstick[i]);
}while(TRUE);
```

## 线程

### 线程的定义

线程的出现是为了减少程序并发执行时的时空开销，让 os 具有更好的并发性。

由于进程还包括了程序运行时的大量资源，因此进程频繁的调度、更替将会导致很大的开销；因此多线程 OS 中将拥有资源的基本单位和分派调度的基本单位分开，**进程只是拥有资源的基本单位，而不是可执行的实体；每一个线程都是一个可执行的实体。CPU 的基本调度单位是线程**。进程处于执行状态实际上是说进程中的线程在执行。

### 线程的特点

1. 调度的基本单位
2. 并发性：一个进程中的多个线程可以并发执行
3. 本身几乎不保存资源，只保存少量自身运行必须的资源，比如寄存器、栈等
4. 多个线程可以共享同一个进程中的全部资源，因此每个线程之间的独立性比较差

### 线程的组成

- 程序段，相当于进程的程序段
- 线程控制块 TCB，保存线程执行的运行状态、优先级、标识等信息
- 少量运行所必须的资源

### 线程的实现

主要有三种线程的实现方式：

- **用户线程（\*User Thread\*）**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
- **内核线程（\*Kernel Thread\*）**：在内核中实现的线程，是由内核管理的线程；
- **轻量级进程（\*LightWeight Process\*）**：在内核中来支持用户线程；

用户线程虽然是由用户自己创建的，但是如果想要像真的线程一样发挥作用，还是需要和内核线程建立联系。具体的联系有一对多、多对一、多对多三种。

#### 用户线程

用户线程是基于用户态的线程管理库来实现的，那么TCB 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。

所以，**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**

用户线程是多对一的关系，即多个用户线程对应一个内核线程。

![用户级线程模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

优点：

1. 方便，轻量，上下文切换速度快，因为是由用户的线程库函数执行创建、调度等操作
2. 拥有可见的TCB，方便管理和控制，甚至可以在不支持线程的操作系统上创建线程。

缺点：

1. 虽然切换和调度快，但是执行比较慢，每个线程得到的时间片较少
2. 线程启动后不能中断，一个线程阻塞会导致所有线程阻塞。

#### 内核线程

内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。

内核线程的模型，也就类似前面提到的**一对一**的关系，即一个用户线程对应一个内核线程

![内核线程模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)

内核的优缺点就和用户线程的恰恰相反。

优点：

1. 分配给线程、多线程的进程获得更多的 CPU 运行时间
2. 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；

缺点：

1. 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；

#### 轻量级进程

轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。

在 LWP 之上也是可以使用用户线程的，且LWP和用户线程的对应关系也有一对一、一对多、多对一三种。再结合它和内核线程的一对一，就是这样的关系：

![LWP 模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/22-LWP.jpg)

## 进程和线程的区别

- 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。
- 切换：线程上下文切换比进程上下文切换要快得多。
- 拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
- 系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O 设备等，OS 所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。
- 状态和调度：线程的状态以及调度方式和进程基本相同，进程的同步方式也适用于线程

# 死锁问题

## 死锁的定义

死锁（Deadlock），是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
通俗来说，死锁出现于采用互斥访问方法、不可以被抢占的资源，即临界资源。
一个进程占用一部分资源并请求下一个资源，但是其中的每个进程都保持这种状态，每个进程都要请求被另外一个进程正在占用的资源，并且没办法放掉自己现在占用的资源，就会造成死锁。即这组进程的**每个进程都在等待另一个死锁进程占有的资源。**

## 产生死锁的必要条件

1. 互斥：进程需要的每个资源都只能同时被一个进程访问，进程都是互斥的。
2. 请求和保持：每个进程自己占有一个资源，又请求下一个资源，并且进程请求下一个资源时并不会释放上一个占用的资源
3. 不可抢占：即进程占用的资源在自己主动释放之前不能被任何手段抢占
4. 循环等待：发生死锁时，必然有一个循环的等待，比如 A 等 B，B 等 C，C 又等待 A，形成环路。

## 预防死锁的方法

核心就是破坏产生死锁的四个必要条件中的一个。具体来说是第 2、3、4 个；必要条件 1，因为它是由硬件设备的固有属性所决定的，不仅不能改变，还应加以保证。

1. 破坏“请求和保持”条件：规定所有进程在开始运行之前，都必须**一次性申请其在整个运行过程所需的全部资源**。
2. 摒弃“不可抢占”条件： 当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须**释放它已经保持了的所有资源**。待以后需要时再重新申请。
3. 摒弃“环路等待”条件：即通过调整合适的进程执行顺序，防止出现环路等待；这个方法就是下面说到的，找到一个“安全序列”

## 避免死锁的方法

避免死锁可以通过一定的算法来解决，核心是保证系统运行过程中的安全状态。

所谓安全状态，是指系统能按某种进程顺序，如`<P1， P2，…，Pn>`，依次为 n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称系统处于安全状态，并称`<P1，P2，…，Pn>`序列为安全序列。否则，如果系统无法找到这样一个安全序列，则称系统处于不安全状态。

系统决定能不能将资源分配给某个进程的依据，就是将资源分配给该进程后，该进程可以执行完成并释放出本来已经占有的资源数量，释放之后（原本就有的+该进程释放出来的）的资源总数仍然能够下一个进程使用。依次对每个进程都进行这样的操作，就可以得到一个安全序列

比如现在系统有三个进程 P1、P2 和 P3，共有 14 台打印机。进程的各需求情况如下：
![](https://pic.imgdb.cn/item/627dd80b0947543129ccaa9b.jpg)

现在可用 3 台，因此可以：

1. 先把 2 台给 P2，P2 完成后返回占用的 2 台，可用 5 台；
2. 把 5 台分给 P3，P3 完成后返回占用的 5 台，可用 10 台
3. 剩下的分给 P1

因此 T0 时刻系统是安全的, 存在一个安全序列`<P2,P3,P1>`

相反，如果在某一时刻分配给任何一个进程都不能满足一个进程的需要，并且分配之后的可用也不可以，就会陷入死锁，这时就是不安全状态。


---

避免死锁的一个著名算法是银行家算法，其核心就是保证每次分配资源时都能找到一个安全序列。



# 计组相关

## CPU

### 冯诺依曼模型

计算机基本结构为 5 个部分，分别是**运算器、控制器、存储器、输入设备、输出设备**

现代计算机是在该模型的基础上发展的，主要有以下几个核心部分：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)

1. 内存：程序和数据都是存储在内存，存储的区域是线性的。存储数据的基本单位是字节。内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1

2. CPU：有32位和64位之分，区别在于一次能计算多少字节数据。32位计算机一次能计算4个字节（4*8=32），64位则可以计算8个字节。位数越大，计算机单次能表示的数越大（32位的最大值是2^32^，64位则是2^64^），计算的次数就会减少，效率也会提高。

   软件也有32位和64位之分，对于软件来说位数表示指令的位宽，因此32位的软件可以运行在64位电脑上，反过来就不行了

   1. 寄存器：存储计算时的数据，由于内存相对较远，一些临时数据没必要存在内存中，就可以存在寄存器中。常用的寄存器有程序计数器、指令寄存器等
   2. 控制单元：控制CPU
   3. 逻辑运算单元：比如加法器等，用于进行计算

3. 总线：用于 CPU 和内存以及其他设备之间的通信，常用的有三种：

   1. *地址总线*，用于指定 CPU 将要操作的内存地址；
   2. *数据总线*，用于读写内存的数据；
   3. *控制总线*，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；

4. 输入输出设备

## 数的表示

计算机中数字的表示方式是浮点数，通常有32位和64位两种。

浮点数采用的记录方式和科学计数法类似；比如十进制数`12345`用科学计数法表示为1.2345*10^4^，二进制数也可以这么表示。我们把这么规范化后的小数点后的部分称为尾数，n次方称为指数，再加上符号位，就可以得到计算机表示浮点数的方式：

![img](https://blog-img-1307852525.cos.ap-chengdu.myqcloud.com/img/float.png)

其中指数的表示是移码方式，即相当于指数+ (2 ^指数位^ - 1) 的值。比如32位的指数的值就是`实际指数+127`，64位的则是+1023。

加上偏移量的目的主要是避免负指数的出现，因为指数位不好表示为负数。

注意这种形式只是计算机记录数值的形式。对于运算过程，可以理解为是把这种形式的数字转为正常的二进制数值再计算。

比如经典的0.1+0.2!==0.3问题，核心原因就是0.1和0.2转换为二进制小数（**乘 2 取整法**）会导致无限循环。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%97%A0%E9%99%90%E5%B0%8F%E6%95%B0.png)


