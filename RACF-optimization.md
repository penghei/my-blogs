# RACF 介绍

RACF 分别表示响应(Response)、动效(Animation)、完成(Completion)、跟手(Follow)，代表了用户在页面使用过程不同阶段面临的多维度体验问题。各指标含义如下：

| 反馈指标     | 评估指标           | 指标释义                                                                                                                                                                                                                                                     | 指标技术化（[流畅度-反馈响应感知高效技术标准](https://km.sankuai.com/page/1216706823)）                                                                                                                                                                                                                                                                   |
| ------------ | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| R-Response   | **响应时延**       | **响应时延主要影响用户对触控交互及时性、控制感和愉悦性的体验评价。**响应时延不应高于用户可容忍的最长等待时间，应避免用户感受到明显的系统延迟，在用户的延迟感觉阈限以上响应时延越短流畅体验越好，响应时延接近或短于感觉阈限后继续减小对流畅体验的收益不明显。 | **概念下沉**：响应从发出指令后到屏幕产生明显变化第一帧之前，指标是系统响应时长。<br />**建设思路：**检测从用户输入产生手势事件至事件被主线程消费结束之间的时间，用于反应用户交互时感受的响应速度。                                                                                                                                                        |
| A-Animation  | **动效时长**       | **动效时长反映的是新页面打开或控件出现过程的时间长短。**主要影响用户对触控交互及时性、连续性和愉悦性的评价。动效时长不宜过长也不宜过短，过长会给用户带来拖沓的感觉，过短则易带来闪跳感。                                                                     | **概念下沉：**从明显变化第一帧到动作完成，指标是动效持续时长。<br />**建设思路：**由于动效与交互设计、动画形态存在强相关，无法通过技术手段进行统一监控，由设计侧统一动效规范，通过线下走查的方式完善动效体验。                                                                                                                                            |
| C-Completion | **完成时延**       | **完成时延包括响应时延、动效时长以及内容加载时间，反映的是用户对响应速度的整体感觉。**主要影响用户对触控交互及时性和愉悦性的体验评价，在一定时延水平以上完成时延越短越好，当完成时延小于一定水平后用户的流畅体验不再继续提升。                               | **概念下沉：**从发出指令后到内容全部稳定显示，指标是页面完成时长。<br />**建设思路：**以首屏图片加载完成并且元素稳定不再变化为页面加载完成时间点，用于反应用户客观感受到的页面加载体验。                                                                                                                                                                  |
| F-Follow     | **最大连续丢帧数** | **最大连续丢帧数反映的是用户感受到画面不连贯，卡顿的程度。**最大连续丢帧数越接近于 0，用户流畅性体验越好。                                                                                                                                                   | **概念下沉：**在页面滑动过程中，用户感受到画面不连贯，卡顿的程度，指标是最大连续丢帧数。<br />**建设思路：**由于用户的流畅度体验受惯性和均值的影响，使用单一指标难以衡量各种场景下的实际体验，最终通过 最小 FPS(minFPS) (页面滚动时每隔 1s 计算一次 FPS 取最小值) + 最大连续丢帧(最多连续的未绘制的帧数) 从平均值和稳定性两个维度共同衡量页面的滚动体验。 |

其中 A 指标一般取决于动效的设计，对于前端来说不太可控。因此大多数时候优化的方向都是 RCF 这三个。在 web 端上也有类似 RAIL 这样的性能指标，表现方式类似。简单来说这三个就是：

- R：从用户输入到做出响应的第一帧的时延，主要优化方向是降低交互产生的性能消耗，保证尽快做出响应。一般来说 100ms 之内为优秀，高于 200ms 就是不可忍受的了。类似于 web 性能中的 FID 指标
- C：即首屏渲染时间，表示完成全部的首屏渲染。这个指标收到手机性能的影响，但一般情况下大于 1000ms 都是不可接受的，300-800 之间都是可以的
- F：一般是**最小帧率+最大连续丢帧**两个指标，minFPS 大于等于 58 且 最大连续丢帧 <= 1 帧则为满意，若 minsFPS 小于 58 但大于等于 55 且 最大连续丢帧 <= 1 则为可容忍，若 minFPS 小于 55 或 最大连续丢帧大于 1 帧则为不可接受。

这几个指标有一些具体的采集方案（即这些指标是怎么获得的），如下：

| 指标   | 采集方案介绍                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | 对标对象                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| R 指标 | 从用户点击屏幕到屏幕刷新新的内容需要经过多个阶段，这些工作如果不能在 100ms 处理完成，用户就会察觉到延迟，操作与用户反应之间的联系就会中断。<br />**针对 MRN 页面 (以 Android MRN 为例)**MRN 页面点击事件相对 Native 更加复杂，完成整个点击事件需要经过多次线程切换，所以我们的整体思路是“追随”点击事件的流转，直到点击事件被 JS 消费并且点击事件修改的布局在 UI 线程完成更新才算时间响应的终点。<br />1. MRN 页面 ACTION_UP 事件首先从 Native 侧传递至 JS 侧，在 JS 侧 ReactNativeRender.receiveTouchs() 方法中触发点击(onPress)事件，在方法末尾调用自定义桥表明 JS 侧执行结束。<br />2. 自定义桥执行后的下次 onBatchComplete() 方法执行将本批次的 ViewOperation 队列转移到主线程并执行，在主线程执行结束后标明 UI 线程完成布局。此时的时间减去开始时间即为交互响应时间。(与 Native 同理未考虑 GPU 绘制的时间)<br /> | [腾讯-Metrix](https://github.com/Tencent/matrix)：使用 Choreographer(Android)/Runloop(iOS) 监听主线程 VSync 帧信号，通过检测主线程每一帧能否在指定时间内完成判断是否存在卡顿。<br />[阿里百川-性能可视化之路](http://pic.huodongjia.com/ganhuodocs/2017-06-19/1497866023.46.pdf)：根据 RunLoop 的状态监听发送到主线程的事件能否在一定时间内完成，若超过一定阈值则认为有发生卡顿。<br />[FID(首次输入延迟)](https://web.dev/fid/)：Web 页面检测首次输入事件至主线程空闲可以处理该事件花费的时间 (方案适用于 PC 和移动端)。                                                                                                      |
| C 指标 | C 指标选取 FSP 指标作为数据来源。FSP 指标在统计页面加载时间时会考虑首屏元素的稳定和网络图片的加载，更能反应用户直观感受到的加载体验。<br />统计起点：容器启动时间、Native 页面启动（第一行代码的时间）。终点时间：以首屏稳定展示(首屏元素稳定且网络图片加载完成)或用户交互为终点时间。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | [秒开率 1.0 官方文档 (公司内部)](https://km.sankuai.com/page/208640480)：首屏可见元素边界超出屏幕或用户交互前最后一次视图变动时间。[秒开率 2.0 官方文档（公司内部）](https://km.sankuai.com/page/1297588602)：首屏可见元素触底，并且屏幕 18 宫格填充率达 90%，如果页面不足一屏，则以交互前最后一次首屏范围内的视图变动时间为页面首屏时间。[FSP (公司内部)](https://km.sankuai.com/page/1018611436)：首屏最后一次大于阈值的视图刷新时间(包括图片加载和视图变动) 或 用户交互前最后一次大于阈值的视图刷新时间（阈值：视图刷新面积 >= 屏幕面积 \* 5%）。[LCP (最大内容绘制)](https://web.dev/lcp/)：首屏最大图像或文本块渲染时间。 |
| F 指标 | 传统的滚动流畅度指标都是从单一的角度反应页面的滚动流畅度，比如我们熟悉的 FPS 是从平均值的角度反应整个页面使用过程中平均的 FPS，降速帧则是关注帧率发生突变的时刻从稳定性的角度反应页面滚动流畅度。我们配合设计侧经过多次的论证：仅使用单一的维度会存在检测盲区无法完全覆盖用户可能遇到的卡顿场景，因此我们采用 连续丢帧 和 最小 FPS 两个指标，从稳定性和平均值两个角度进行衡量。<br />**最小 FPS(minFPS)：**每隔 1s 计算一次 FPS，取该页面元素滚动期间最小的一次 FPS 值。<br />**最大连续丢帧**：连续丢帧 n = 帧耗时 ms / (1000 / 60) - 1，取该页面元素滚动期间最大的一次连续丢帧。                                                                                                                                                                                                                                   | [腾讯-PerfDog](https://perfdog.qq.com/article_detail?id=10162&issue_id=0&plat_id=1): 考虑视觉惯性，下一帧耗时大于前三帧耗时的 2 倍，则认为是一次潜在卡顿。[Metrics 降速帧 (公司内部)](https://km.sankuai.com/page/1215345279)：占用 VSync 数比前一帧更多的帧。[FPS](https://baike.baidu.com/item/FPS/3227416)：1s 内页面刷新的次数。                                                                                                                                                                                                                                                                                           |

# RCF 优化

## 优化工具

有一些性能检测的工具可以帮助发现性能问题，如：

| 工具                                                                                                                           | 功能介绍                                                                                                                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Flipper**[Flipper 安装地址](https://github.com/facebook/flipper/releases)                                                    | Flipper 是 FaceBook 提供的，可以用于调试 iOS 、Android 、React Native 应用程序的平台。使用其提供的 Profiler 工具，可以方便的查看 MRN 页面中组件的渲染耗时、渲染次数等信息。                                                                  |
| **Why-Did-You-Render**[重复渲染检测工具](https://km.sankuai.com/collabpage/1467658189)                                         | wdyr 组件可以帮助我们快速发现 MRN 页面中存在重复渲染的组件以及重复渲染的原因，是排查解决页面重复渲染的利器。                                                                                                                                 |
| **Profiler** [Profiler 工具](https://km.sankuai.com/page/1146778406)[Caesium (iOS 侧)](https://km.sankuai.com/page/1363267844) | Profiler 是一种高效的获取 Java 线程调用栈工具，可以在代码中自定义开始、结束时间点精准的统计堆栈执行耗时，且能够同时采集多个线程，对于分析线程阻塞、线程耗时任务等非常有帮助。（类似于 web 控制台的 profiler 工具以及 React DevTools 的工具） |

## 优化案例

下面是官方文档的一个优化案例：

某列表页在列表切换到地图模式时，存在明显的卡顿，用户点击后需要经过较长的时间页面才会发生变化。

具体功能是：用户点击列表上的一个商卡，然后转移到地图上显示具体商卡对应的商家的位置。即从列表点击到展开地图、高亮位置这个过程

性能问题发生在用户点击商卡后页面呈现“卡死”状态，经过 600ms+ 后地图才放大并显示位置。

优化过程发现的主要问题有：

1. **重复渲染**

   从列表切换到地图时若列表中存在打开的弹框需要先关闭掉。在没有弹框的情况下理论关闭所有弹层这一步不应该有性能损耗，但实际测试发现扔存在 60+ms 的耗时。从代码角度分析不会执行有意义的业务逻辑，但还存在耗时极有可能是出现了重复渲染，使用重复渲染工具(**Why-Did-You-Render**) 检测发现在执行关闭弹框方法时存在很多不必要的渲染。

   Why-Did-You-Render 输出结果如下 (prev activityFilterType 表示重复渲染前组件的 props 属性、next activityFilterType 表示重复渲染后组件的 props 属性)，从输入的内容即可发现两个不同的对象但实际内容是一致的。

   ![](https://pic.imgdb.cn/item/649fe0df1ddac507cca8e54b.jpg)

   排查代码发现 activityFilterType 来自 Store 中 filterModal 属性，关闭弹框时会朝 Store 中存入 { modalType:5, tag: null }，虽然内容没变但每次都是一个新的对象。解决方案就是在修改 Store 前判断下内容是否真的发生变化，若没有发生变化则避免修改 Store，由此减少了组件无意义的重复渲染。

   ![](https://pic.imgdb.cn/item/649fe0eb1ddac507cca8fbf9.jpg)

   使用相同的思路逐步解决了列表切地图各个阶段存在的重复渲染，但优化后发现列表切换地图还存在 500ms 左右的卡顿，此时检测页面已不存在重复渲染。接下来使用 Profiler 工具分析具体是那些组件还有比较大的耗时。

2. **发现并治理预期外渲染**

   我们使用 Profiler 查看列表切换大地图时组件耗时情况，可以发现渲染耗时主要集中在 CardListPannel (地图底部横滑卡片组件) > Carousel > ScrollView 及其内部的大量子组件，单次的渲染耗时达到 377.5ms。
   从火焰图中还可以看出一些信息：CardListPannel 组件一次性渲染了大量子视图（火焰图中每一个小块代表一个子 View），但从视频中可以看出用户切到大地图后实际只会看到一张底部卡片，由此基本断定列表切换地图时地图底部卡片组件渲染了大量可不见的元素导致了切换时的卡顿。

   ![](https://pic.imgdb.cn/item/649fe1041ddac507cca921fe.jpg)

   排查代码，CardListPannel 内部使用 ScrollView 实现横滑功能，一次性绘制了全部卡片(住宿列表地图底部卡片有 24 个 Cell)。查到问题原因后就好解决了，我们使用 FlatList 替换 ScrollView，控制首次渲染的卡片个数。

# 项目中实际 RCF 优化

## 优化方案

项目中主要的优化方向：

| 优化方案         | 方案说明                                                                                                                                | 优化方向 |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------- |
| 预请求           | [预请求](https://sky.sankuai.com/docs/gfe/cube-native-docs/developGuide/project/performance/prenetwork.html)(提供 mrn 桥自定义触发时机) | 前置优化 |
| 预下载           | jsbundle 预下载                                                                                                                         | 前置优化 |
| 预请求时机前置   | [前置触点矩阵组件接入文档](https://km.sankuai.com/collabpage/1379387274)                                                                | 前置优化 |
| 下载格式优化     | [兜底转换 Webp 方案介绍](https://km.sankuai.com/page/1335665871)                                                                        | 图片优化 |
| 下载尺寸自适应   | [图片自适应裁剪方案介绍](https://km.sankuai.com/page/1313094221)                                                                        | 图片优化 |
| 图片分级加载     | [RN 图片下载优先级说明文档](https://km.sankuai.com/page/1454785150)                                                                     | 图片优化 |
| 图片预下载       | [图片预下载](https://km.sankuai.com/page/1496720567)                                                                                    | 图片优化 |
| 包体大小优化     | [MRN Bundle 体积的深度优化](https://km.sankuai.com/page/192468332)                                                                      | 包体优化 |
| 内联 + ramBundle | [MRN 页面加载提速之内联引用与 RAM bundle](https://km.sankuai.com/page/295532469)                                                        | 包体优化 |

## 优化大纲

- 性能问题来源，有什么性能问题
  - 公司内项目性能指标平台：RCF，尤其是 C 评分很低
  - 会场页首屏渲染慢，拖动列表时掉帧卡顿，屏幕闪烁
  - 其他：比如 CLS 过大，骨架屏
- 性能问题指标，初期性能问题发现，优化效果的体现
  - 监测工具（优化效果体现）
    - 接入的公司内部平台（优化之后，C 指标上升，C 时间减少）
    - 代码接入：计算渲染时间，通过 raptor 实现线上打点记录，统计首屏加载包下载、加载耗时、主接口耗时、首屏模块渲染时长。
    - rn 调试工具，mrn 自带的 RCF 计算
  - 检查工具（检查性能问题）
    - whydidyourender
    - profiler
    - Fllipper（暂定）
- 怎么做的优化
  - 不同方面
    - 主会场的 C，首屏渲染
    - 主会场掉帧问题，重复渲染
  - 优化目标
    - 主流程页面 RCF 平均分提升到流畅（>= 60 分），其中 C 指标期望提升到 40 以上。（优化前会场的 C 只有 2，优化后希望提升至 30 以上）
  - 整体方案：
    - 经调研发现到餐（[到餐主流程 RACF 优化立项](https://km.sankuai.com/collabpage/1536226885)）和到综（[RCF 优化方案全景](https://km.sankuai.com/page/1341247797)）有部分优化手段，但整体缺乏更精细地打点数据，难以评估具体优化策略带来的收益和遇到的瓶颈。因此我们决定先建立完备的页面性能打点统计当前的页面性能瓶颈，然后先上一版通用低成本的优化策略，最好再根据性能瓶颈进行专项优化
    - 线上和线下的性能观测数据不同，因此采用不同的方式监测性能。线上通过 raptor 打点上报以及平台统计数据，线下可以通过[RACF 指标线下测试 SOP](https://km.sankuai.com/page/1305841457)进行分析
  - 优化方式
    - 主会场页面加载时间
      - 懒加载 Carousel 和 video，初始采用三个商卡占位，加载完成 Carousel 和 video 后再显示。懒加载的理论依据：
        - [mrn 分包](https://km.sankuai.com/docs/mrn/page/293886135)
        - [rn 分包](https://reactnative.cn/docs/ram-bundles-inline-requires)
        - 其他相关文档：[MRN 页面加载提速之内联引用与 RAM bundle](https://km.sankuai.com/page/298098639)、[MRN 页面加载速度优化方式之懒加载](https://km.sankuai.com/page/275397094)
      - 通过**Priority 组件**降低 Carousel 的渲染优先级，使其延后渲染
      - 骨架屏优化和占位元素，防止页面大幅度抖动，降低 CLS
      - 商卡背景图和头部背景图采用优化方案中的图片优化方式
    - 主会场掉帧、闪烁、卡顿
      - 通过 whyyourender 检查重复渲染出现的位置，即列表滚动导致 redux 更新导致重渲染
      - 使用全局事件代替 redux
      - 使用 Animation 代替 state 更新（nav 渐变色、背景图放大）
    - 预加载
      - 会场页预加载视频沉浸页
      - 点击跳链时预加载二级页
    - 图片优化
      - 降低分辨率
      - 预加载，预先占位
      - 懒加载
      - 设置加载优先级。优先级机制在组件内含有，也可以使用上面说的 Priority 组件实现
    - 其他
      - 类比 RACF 官方文档中的优化案例，挑选一些编一些。比如 ScrollView 改 FlatList 之类的
      - 图片优化，比如懒加载、webp 格式、降低分辨率等
      - 包体优化，比如 lodash、moment 等
      - 接口优化，比如会场刷新的分散请求，会场页到沉浸页的数据缓存等
      - 内存优化，可见于[MRN 内存优化](https://km.sankuai.com/page/652206431)。还有一个内存优化的点是，当离开页面时清除视频资源，终止播放，卸载组件，以减少内存消耗
      - 渲染优化，常见方式可见https://zhuanlan.zhihu.com/p/152146482，从中挑一两个实现
  - 其他业内优化方式
    - [住宿门票主流程 MRN 化实践总结](https://km.sankuai.com/page/200118658)
- 优化效果->体现于性能指标
  - 优化了多少
    - C 指标提升
    - 响应时间原本 3000ms 以上->减少 1000ms 左右
    - 闪烁情况消失，帧数提升并能稳定五六十，极少出现掉帧
    - CLS 降低，体验变好
    - 二级页进入速度更快，秒开率更高

还需要了解的一些点，可以在文档搜下

- 首屏渲染，计算指标、依据，内部优化方式
- async-storage，缓存请求数据
- 轮播组件优化
- 页面直出方案
- 优先级渲染，图片优先级加载案例
- 懒加载和分包方案的实际用例
- 一些特殊的方式，比如
  - 分批次渲染/渐进式渲染/延迟渲染，这三个类似，因为都是大致按照延迟渲染的方式进行
  - 按需渲染，比如对于浮层或者二级界面
  - 请求分布，按需请求，不在首屏需要的请求可以分离（比如券包和会场list）