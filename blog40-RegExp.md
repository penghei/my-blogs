---
title: 正则表达式学习和常用正则
date: 2022-02-02 18:25:26
tags: 日常学习
cover: /img/canvas.jpg
categories: 工具
---

# 正则概述

> 正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

在 js 中，正则常用于表单验证、字符串提取和替换等。

# js 中正则的使用

js 中正则属于 RegExp 对象，可以构造，也可以在两个斜线中写出
构造 RegExp 对象时参数是字符串，不用写两边的`/ /`，但是注意内部的字符要转义，比如`\`字符就要写作`\\`，`\$`就得写作`\\$`

```js
const re = /^\d{3}\-\d{3,8}$/;
//or
const re = new RegExp("^d{3}-d{3,8}$");
re.test("010-11223344"); //true
```

正则的常用方法：

- `re.test()`:参数是被测试的字符串，找到正则匹配的部分返回 true，否则返回 false
- `re.exec()`:参数是字符串，用于分组，前提是 re 要有`()`产生的分组；返回一个数组，例如：

```js
const re = /([0-9]+)([a-z]*)/;
re.exec('123abc')

[
    '123abc',
    '123',
    'abc',
    index: 0,
    input: '123abc',
    groups: undefined
]
```

具体参考<a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec'>MDN</a>

- `string.match()`：参数是正则表达式，返回一个数组表示匹配结果，比如：

```js
'hello1234hello123'.match(/h/)
返回：
[ 'h', index: 0, input: 'hello1234hello123', groups: undefined ]

'hello1234hello123'.match(/h/g)
返回：
[ 'h', 'h' ]
```

- `string.matchAll()`：参数的正则**必须是全局**，即必须要/g；返回所有匹配到的 match 返回，也就是多个 match 第一种返回类型

- `replace`：和 js 原生的 replace 方法一样，但是第一个参数也就是查询的字符可以是正则表达式，找到后替换；`replaceAll`同理
- `split`：和原生 js 一样，参数可以是正则，根据正则做一些更加精确的分割

```js
const re = /[\s\,\;\.]+/; //至少一个空格/逗号/分号/句号
"a  , b ;c  . d".split(re);
//[ 'a', 'b', 'c', 'd' ]
```

- `search`：返回找到的字符位置（实际上是匹配到的部分的前一个位置），没找到返回-1；

# 正则语法

## 基本语法

正则中每一个单独无修饰的字符都表示单独匹配
比如`/abc/`表示一个字符串中寻找`'abc'`
正则没有连接符，每一个部分之间都表示一种匹配
比如`/[0-9]@[a-z]/`表示匹配`1@b`这种形式

---

一个例子：
![](https://www.runoob.com/wp-content/uploads/2014/03/CEBB49BB-B1AD-4539-AC7A-B40DDC62D1B2.jpg)

- `^ `为匹配输入字符串的开始位置。
- `[0-9]+`匹配多个数字， `[0-9] `匹配单个数字，`+` 匹配一个或者多个。
- `abc$`匹配字母 `abc` 并以 `abc` 结尾，`$ `为匹配输入字符串的结束位置。

---

另外一个例子：
![](https://www.runoob.com/wp-content/uploads/2018/09/regexp-cn.png)

## 特殊字符

正则表达式中有一些字符可以用于匹配特殊字符，或者特殊数量的字符
常用的有：
|字符|含义|
|---|---|
|`\d`|匹配一个数字|
|`\D`|非数字|
|`\w`|一个字母或数字和下划线，相当于`/[A-Za-z0-9_]/`|
|`\s`|一个空白符，包括换行|
|`\S`|非空白符，不包括换行|
|`\b`|单词边界，比如`i am a boy`这句话中的边界为`|i| |am| |a| |boy|`，下面会详述|
|`\B`|非单词边界|
|`\xhh`|一个两位十六进制数（\x00-\xFF）表示的字符。|
|`\uhhhh`|utf16 字符|
|`.`|除了\n \r 之外的任何单个字符;如果正则的修饰符有 s,则包括\n|
|`^`|匹配开头,表示匹配字符串中以^后面的字符开始的部分;比如`/^abc/`表示匹配 abc 开头的字符串;如果在`[]`内部表示不包括方括号的内容|
|`$`|匹配结尾,和^类似|
|`*`|表示前面的字符存在>=0 次|
|`+`|表示前面的字符存在>=1 次, 也就是至少一次, 无上限|
|`?`|表示前面的字符出现 0 或 1 次, 不能超过一次|
|`()`|表示分割字符串, 可以用于把正则划分为几部分；在 test 方法中没有区别，但是在 exec 方法中会根据括号划分的部分来分割字符串|
|`{}`|内部填入数字，有三种形式，用于表示前面字符的个数限制；{n}表示限定为 n 个，{n,}表示至少为 n 个，{n,m}表示 n 到 m 个|
|`[]`|表示一个范围，内部填入的可以被划分在一起表示一种配，下面会详述|
|`\|`|表示“或”，常用在()或[]中|

---

下面详述亿些比较特殊的：

#### \b

代表着单词的开头或结尾，也就是单词的分界处。\b 不会匹配一个具体的字符，而是一个位置；

> \b 匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在) \w。

- 每一个字符和空格、换行、制表等字符都占有一个“显式位置”
- 字符与字符之间还有一个位置没有任何东西，这样的位置叫“隐式位置”。通俗的理解，\b 就是“隐式位置”

比如这样一句话：

```
Hello, my JavaScript RegExp.
```

把\b 匹配的位置换成|，就是这样：

```
'|Hello|, |my| |JavaScript| |RegExp|.'
```

在实际使用过程中，\b 常放在要匹配的字符两边，表示匹配英文句子中的单个单词而不是一串连续字符中的部分
比如:

```
/\bcat\b/表示单独的cat单词
'it is a cat'会匹配cat
'aabccattdd'不会匹配，因为这个字符中的cat两边没有单词边界
```

---

理解了\b，\B 就是反向，也就是非单词边界；使用的时候可以专门匹配在一串字符内部的部分。

#### ?

单独的`?`没有特殊含义，但是`?`后面跟一些将会有不同的匹配形式
注意下面的形式都是在括号内部的

##### (?:x)

> 匹配 'x' 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。

在匹配上和`()`没有区别，但在 exec 等方法中不保存
比如：

```js
"123abc".exec("([0-9]*)([a-z]*)");
//结果：['123abc','123','abc']

"123abc".exec("(?:[0-9]*)([a-z]*)");
//结果：['123abc','abc']
```

可以看到虽然匹配了第一个`[0-9]`，但是没保存在结果中

##### x(?=y)

> 匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。

意思就是，只匹配后面为 y 的 x

例如，`/Jack(?=Sprat)/`会匹配到'Jack'仅当它后面跟着'Sprat'。
也就是`"afasgfafJackSpratafsfaf"`会匹配到里边的 Jack
但是`"asfasafJackafsafs"`不会匹配到 Jack

##### (?<=y)x

匹配前面是 y 的 x。这种叫做后行断言。

##### x(?!y)

匹配后面不为 y 的 x，是`/x(?=y)/`的反向，这被称为正向否定查找。

例如，`/\d+(?!\.)/` 匹配一个后面不是小数点的数字。exec("3.141")匹配‘141’而不是‘3.141’

##### (?<!y)x

匹配前面不是 y 的 x，反向否定查找。

`/(?<!-)\d+/.exec('3')` 匹配到 "3".
`/(?<!-)\d+/.exec('-3')` 因为这个数字前有负号，所以没有匹配到。

#### ^和$

寻找字符串的开头或结尾部分
^和$修饰的匹配表示一个开头或结尾的限制
比如：

```
两个正则：
/[0-9]+[a-z]/
和
/^[0-9]+[a-z]/

两个字符串：
"aaaa0123a"
"0123abbb"
```

对于`"aaaa0123a"`，第一个正则会匹配到`"0123a"`;

第二个正则只能匹配"`0123abbb"`中的`"0123a"`，`"aaaa0123a"`则匹配不到，因为第一个不是数字开头的
`$`类似，限制结尾。

---

这里还有几个注意点：

1. 如果没有括号，这两个符号会匹配其后跟着的所有字符，直到下一个括号为止
   也就是说`/^foo123/`会匹配开头为 foo123 的字符，而不是开头为 f，后面 oo123 的字符；`$`同理
2. 前有`^`、后有`$`的表示只能出现一次，并且整行只能出现一次，叫做整行匹配

#### []

表示一个范围，方括号内部可以是任意字符或范围；括号外面可以有表示数量或开头结尾的特殊符号

- 范围： 
  - `[0-9]`：数字 
  - `[a-z]`：小写字母 
  - `[A-Z]`：大写字母
  范围可以写多个，比如`[0-9a-zA-Z\-]`表示数字、大小写字母和连字符
- 外部特殊符：
  - `[0-9]+`表示至少一个数字，可以匹配很多个数字直到不是数字的一位为止，`[]*`也是同理
  - `[a-z]{2,6}`表示匹配 2-6 个小写字母，超过 6 个或者小于 2 个匹配不到；
  - `^[A-Z]`表示匹配大写字母开头的字符，并且只匹配第一位大写字母；如果字符串第一位不是大写字母就匹配不到；后面可以跟数量修饰符表示开头的大写字母个数；其后的部分表示除了开头之外的。`[A-Z]$`同理

## 修饰符

放在正则末尾，表示一些限制
修饰符常用一共有四个：
|修饰符|含义|描述|
|---|---|---|
|i |不区分大小写 |将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。|
|g |全局匹配 |查找所有的匹配项。（如果没有的话默认找到第一个就截止，后面的不再查找）|
|m |多行匹配 |使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。|
|s |特殊字符`.`中包含换行符 \n |默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。|

修饰符可以多用，比如 gi、gs 等等，并不限制数量

# 复杂正则及解释

这里举一些有学习意义的复杂正则
js 正则基本上用于表单验证，因此不需要太过复杂

- 匹配邮箱：
  `/\b[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,6}\b/g`
  ![](https://www.runoob.com/wp-content/uploads/2014/03/regexp-metachar-2020-11-23.png)
  如果不是在许多单词内部，不需要\b 也可以
- 身份证号：
  `/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/`
  表示 15、18 位或者 17 位数字和 x
  当然身份证号可以做进一步的验证，因为中间的出生年月是有固定限制的
  `/^(\d{6})(19[0-9][0-9]|20[0-1][0-9]|202[0-2])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(\d{4}|\d{3}X|\d{3}x)$/`
  中间的部分表示限制年份在 19xx 到 2022 年之间，然后是月份和日期的限制
- 强密码限制：（必须包含大小写字母和数字的组合，可以使用特殊字符）
  `/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{n,m}$/`
  这里用到了`(?=xxx)`表示"必须含有 xxx"，原理是：
  `(?=.*\d)`匹配一个字符串，该字符串后接任意字符+数字。这个字符串实际上就是空字符串。因此在正则表达式"`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{m,n}$`"中。`(?=.*\d)(?=.*[a-z])(?=.*[A-Z])`都表示匹配那样一个空字符串。也就意味着我们的密码必须包含数字、大小写字母。
- 十六进制颜色（#fff）与 RGB, HSL 颜色的相互转换
  - 匹配十六进制颜色：`/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})/`
  - 检查是否为 rgb 开头：`/^(rgb|RGB)/`
  - 替换 rgb 的“rgb”字符以及左右括号：`/(?:\(|\)|rgb|RGB)*/g`，用 replace 方法替换为空

---

完整代码：

rgb 转为十六进制颜色，原理就是用正则提取出rgb后面的三个数字，然后通过转换得到16进制数:

```js
const colorHex = function (color) {
  const that = color;
  //十六进制颜色值的正则表达式
  const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  // 如果是rgb颜色表示
  if (/^(rgb|RGB)/.test(that)) {
    const aColor = that.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    const strHex = "#";
    for (let i = 0; i < aColor.length; i++) {
      const hex = Number(aColor[i]).toString(16);
      if (hex.length < 2) {
        hex = "0" + hex;
      }
      strHex += hex;
    }
    if (strHex.length !== 7) {
      strHex = that;
    }
    return strHex;
  } else if (reg.test(that)) {
    const aNum = that.replace(/#/, "").split("");
    if (aNum.length === 6) {
      return that;
    } else if (aNum.length === 3) {
      const numHex = "#";
      for (let i = 0; i < aNum.length; i += 1) {
        numHex += aNum[i] + aNum[i];
      }
      return numHex;
    }
  }
  return that;
};
```

---

十六进制颜色转为 RGB

```js
const colorRgb = function (sColor) {
  sColor = sColor.toLowerCase();
  //十六进制颜色值的正则表达式
  const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  // 如果是16进制颜色
  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      const sColorNew = "#";
      for (let i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }
      sColor = sColorNew;
    }
    //处理六位的颜色值
    const sColorChange = [];
    for (let i = 1; i < 7; i += 2) {
      sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
    }
    return "RGB(" + sColorChange.join(",") + ")";
  }
  return sColor;
};
```

# 常用正则

https://c.runoob.com/front-end/854/
