# 超管项目

## STAR 总结

1. S: 背景

该项目的背景主要是实现一个地图，能够实时显示一些点位在地图上的位置、点位的名称、坐标等相关信息，以及关于点位的简单交互（比如点击选中）。除此之外还会渲染机器人的位置，方便用户在地图上查看机器人和其他点位之间的距离、角度等位置关系。

具体的项目需求，是在已有的地图之上绘制点位。即存在现有的地图图片，我们需要把点位绘制在地图的正确位置上，同时保证一定的交互性。

考虑到我们需要独特的点位绘制方式和交互方式，现有的地图组件库不能满足交互功能的实现，因此采用 canvas 来实现绘制功能。

原生 canvas 开发较为麻烦，因此在开发之前调研了不同 canvas 库。考虑的因素有：

- 要便于使用，api 简洁
- 要有事件系统，能实现交互
- 最好有常用功能的封装

调研的库主要有：

- Fabric：和 konva 类似，也有事件系统，但他和 react 的结合不如 konva 这种组件形式。
- react-canvas：这个库非常老，已经没有人维护了
- konva 和 react-konva：选用的主要原因是有类似 react 组件的开发方式，而非命令式的绘制，开发逻辑上更加清晰。

最后选定了 react-konva 来开发。

2. T：目标

基本目标是：完成项目需求，即

- 实现地图绘制和点位绘制，点位能显示在正确位置上
- 实现基本的交互，比如点位的选中高亮、鼠标悬浮显示、点位名称显示，以及地图的放大和拖拽。
- 优化部分性能，在实现功能的基础上使用一些优化手段来保持性能，对于点位数量多的情况要做一些优化来保证拖拽、放大过程稳定。

3. A：行动

首先是基本绘制功能的实现

- 绘制地图：按照绘制背景图的方式将地图绘制在 canvas 上。canvas 大小固定。初始化时地图放缩比例为最小，不能再缩小或拖拽。以 canvas 的宽为标准，显示的图片的宽设置和 canvas 宽一样，可以保证不会出现空白
- 坐标映射：服务端下发的是地图的原点和点位相对于原点的坐标。以地图左上角为原点，从真实坐标计算到 canvas 坐标就是`(真实点位x - 真实点位原点x)/比例尺 * 缩放比例`。其中比例尺也是服务端下发的，和地图本身有关系。缩放比例初始化为`canvas宽度 / 地图图片的实际宽度`，并不等同于实现放大缩小时的缩放宽度。如果在这个基础上再实现放大功能，那么就还要乘上放大的比例。
- 绘制点位：通过服务端下发的点位数据绘制具体的点位。绘制过程类比渲染列表元素的实现。点位本质上就是一个带有边框的圆形，因此我们把点位抽象到一个单独的组件内。

```js
const Point = ({ point }) => {
  return (
    <Circle
      x={point.x}
      y={point.y}
      radius={50}
      fill={point.color}
      stroke="black"
      strokeWidth={2}
    />
  );
};
```

- 绘制机器人位置：和绘制点位一样，根据坐标绘制出机器人的位置。

然后在绘制完成后，实现基本的交互功能

- 点击点位可以高亮，点位颜色改变、大小改变。实现方式就是监听事件，然后修改点位的属性。
- 点击事件的问题：冒泡问题
  在项目中遇到了这样的问题：需求需要显示一个盖在原地图上的实时地图，实时地图内有很多点位，希望点击这些点位时，能获取到具体点的是哪个点位。
  这是一个常见的事件委托的需求，但是需要事件冒泡作为基础。由于 konva 的事件系统是自己模拟实现的，因此与 dom 的事件机制不一样，在使用时出现了一些问题。
  - 尝试：
    - 放在绘制的父元素上，无效
    - 猜测可能是和组件先后顺序有关，尝试后也无效。
    - 希望把事件绑定在实时地图容器上，而不是绑定在外部的 html 上。
  - 查阅资料：
    - 官方文档，没有详述 react 中事件冒泡的规则
    - github issues 没有
    - 查看源码
      - 先是了解 konva 事件系统的实现原理
        - 调试源码
        - 搜一些资料，查看事件原理
      - 事件冒泡的机制：fireAndBubble，以及查找的“parent”到底是谁
      - 最后了解到每个元素都有一个 parent，但是 parent 只在 Container 中被设置，并且必须调用 add 方法。Container 只有 stage、layer 和 group，普通元素不行。
  - 解决方案
    - 使用 Group 把实时地图和实时点位包裹起来，然后在 Group 上监听事件。
    - 同时还了解到了取消事件冒泡的机制，在 Group 上通过 cancelBubble 防止事件进一步冒泡

交互和绘制之后，就是实现拖拽放大功能

- 拖拽的实现：本质上是 canvas 元素的拖拽，配合类似 dom 的事件系统。
  - 实现方式：
    1. 获取上次记录的 mouseX 和 mouseY，初始化不存在
    2. 监听 canvas 的 mousedown、mousemove 和 mouseup 事件，当 mousemove 执行时，获取实时的鼠标坐标，和 mousedown 时获取的鼠标坐标的差值就是偏移量。
    3. mouseUp 内记录本次的鼠标位置到 useRef，表示下次偏移的起点。
    4. 修改 stage 的 x 和 y 来更改绘制
    5. 注意边界控制，stage 的 x 和 y 不能小于 0，也不能超出最大值（`初始化的canvas最边缘坐标 * 放大比例`）
- 缩放的实现：修改 stage 元素的 scale
  - 实现方式：
    1. 监听 wheel 事件，通过 deltaY 获取滚动方向
    2. 记录鼠标位置和当前缩放比，计算绝对偏移量`(pointer.x - stage.x()) / oldScale`
    3. 通过 scale 方法放大，维持一个放大比例的 ref，放大过程相当于每次加
    4. 再位移到新的位置，`pointer.x - old.x * newScale`

最后，为了保证绘制性能的稳定，还做了一些基本的优化
优化过程也是 STAR：

- S：项目的实际点位数量不多，在开发阶段没有出现特别明显的卡顿、掉帧等问题。但是测试时发现如果把点位增加到 50 个以上，就会出现拖拽时不流畅的问题。考虑到项目的可拓展性，决定作出一些基本的性能优化。
- T：优化指标以 performance 工具为主，将点位设置为 50 个，检查绘制过程的火焰图，避免出现绘制任务超过很多帧的情况。当到达 50 个时，发现绘制的任务时长虽然有分片，但单个片依然达到了 20ms 甚至 30ms 以上，超出了一帧的时间。
- A：首先需要了解一些 canvas 的常用渲染稳定的优化方式，包括：
  - 绘制方面
    - 减少绘制
    - 分层
    - 批量绘制
    - 时间分片
    - 局部绘制
    - 离屏渲染
  - 计算方面
    - 优化指令
    - 降低数据计算开销
    - 整合数据，降低上下文切换消耗
  - 在这个基础上，我们首先要知道 konva 已经做了哪些优化，哪些是我们需要自己做的。阅读和调试源码以及官方文档得知 konva 已经做了很多优化，我们能额外做的还有一些。
  - 实际做的：
    - 可视区域绘制：使用 map 遍历点位数组时，根据当前画布的坐标和点位坐标计算，如果超出画布边界就不作绘制，不会渲染该组件
    - 缩小到一定比例时不显示元素：点位下方默认有该点位的名称。我们根据测试，设置比例缩小到一定程度时不渲染名称，即删除了显示名称的元素
    - 点位绘制时子组件减少重复渲染：将点位组件封装，并通过 memo 的方式防止更新导致每个子组件重新绘制。
      > 子组件减少重渲染并不是能使得 konva 只绘制一个元素，而是能减少总的绘制次数。konva 的重绘方式是 clearRect 清除全部内容再重新绘制，并没有做到单独区域的绘制。但是我们可以减少影响的组件数量，从而降低绘制次数。
    - 为点位组件使用 cache，在绘制之前调用 cache 缓存，后面绘制的都是 clone 的对象而非原本的元素。
- R：结果：元素超过 50 个时的单次渲染耗时降低，不超过 12ms；拖拽时卡顿的情况减轻。

4. R：结果。

结果主要是几个方面

- 实现了地图的基本功能，能正确显示点位、点位信息、机器人位置等
- 实现了地图的基本交互能力，能实现点位的交互；事件问题得到解决，可以通过事件委托来实现点位选择
- 应用了部分优化手段，保证了在点位数量大的情况下的性能稳定，并通过 performance 来检查性能。

## 遇到问题

### 需求问题

##### canvas 问题

首先是计算地图坐标和 canvas 坐标，相互转化
主要有以下几点：

1. 地图是一张图片，通过 drawImage 绘制到 canvas 上。这个过程中，绘制的大小，即传入的绘制宽高会导致图片放缩。所以要记录比例 scale
2. 接口给出了地图的真实宽高、真实坐标原点的 xy 值，以及真实点位的坐标 xy 值。从真实坐标计算到 canvas 坐标就是`(真实点位x - 真实点位原点x)/比例尺 * 缩放比例`。

这个地方比较抽象，不容易想到

还有就是获取 canvas 上鼠标点击事件的坐标，基本方法是用到了 getBoundingClientRect

```js
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");
function handleClick(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  console.log(`Clicked at (${x}, ${y})`);
}
canvas.addEventListener("click", handleClick);
```

##### konva

- 为什么选用？
  - 减少 canvas 代码，直接用命令式绘制，或者使用 react-konva，直接采用组件的形式，像写 html 一样
  - 解决事件问题。这也是不选用其他库的一个原因，konva 有独特的事件系统。
    其他选项有：
    - Fabric：和 konva 类似，也有事件系统，但他和 react 的结合不如 konva 这种组件形式。
    - react-canvas：这个库非常老，已经没有人维护了
- 怎么用？
- 什么原理

##### recoil 和 redux

- 为什么用：组件拆分，零碎组件多，不用的话状态难以共享，context 太复杂
- redux：框架自带。主要有一些问题：
  - reducer 代码庞大。一个 reducer 只能维护一个状态，因此很多零散的状态就需要很多 reducer。如果把他们合并到一个 reducer，看起来很乱，并且会导致无谓的更新
  - 组件内很难用。dispatch 传入的 action 不能得到类型，需要不停地返回去查看 action.type 名称；后来封装了创建 action 的函数，但是导致了更多的代码
- recoil：自行选择。主要目的：
  - 代码简洁
  - 解决状态零碎问题，atom 本来就是推崇零碎状态。

## 学到知识

- 技术选型：状态管理库的了解，redux、mobx 的原理、recoil 的优势，其他状态管理库之间的优劣比较
- konva 的使用，konva 的事件原理和设计模式，react-konva 和 react 的结合方式
- canvas api，canvas 基础功能的实现，canvas 优化
- 代码规范，四个方面的代码规范
- 工程化代码规范的方式（eslint、husky）

## 项目难点

### 1. 事件冒泡规则

问题：
在项目中确实遇到了这样的问题：有一个这样的需求，即显示一个实时地图，实时地图内有很多点位，希望点击这些点位时，能获取到具体点的是哪个点位。
这是一个常见的事件委托的需求，但是需要事件冒泡作为基础。由于 konva 的事件系统是自己模拟实现的，因此与 dom 的事件机制不一样，在使用时出现了一些问题。

个人尝试：

- 尝试把 onclick 事件放到实时地图的矩形上，发现虽然地图表现为“包裹”着点位，但是实际上不能触发冒泡
- 然后猜测可能是跟先后顺序有关，尝试后也无效。
- 最后猜测应该把实时点位作为地图的矩形的子元素，或者用一个大的元素包裹这两个元素，都不行
- 如果把事件绑定在 layer 或 stage 上，这两个上面已经有其他事件的绑定了，并且实时地图和实时点位是选择渲染的，不一定有，因此希望把事件绑定在实时地图容器上，而不是绑定在顶层。

查阅资料：

- 官方文档，有讲事件的部分，但是没有详述冒泡的规则，并且 react-konva 文档中也没有说事件流的相关概念
- github issues：查找有关事件冒泡的 issues，没有，然后查找其他关于事件系统的 issues，也没有
- 最后，查看源码
  - 先是了解 konva 事件系统的实现原理
    - 调试源码
    - 搜一些资料，查看事件原理
  - 然后搞清楚事件冒泡的机制：fireAndBubble，以及查找的“parent”到底是谁
  - 最后了解到每个元素都有一个 parent，但是 parent 只在 Container 中被设置，并且必须调用 add 方法。Container 只有 stage、layer 和 group，普通元素不行。

解决方案

- 在 Container 上放置事件监听。使用 Group 把实时地图和实时点位包裹起来，然后在 Group 上监听事件，即可。
- 同时还了解到了取消事件冒泡的机制，在 Group 上通过 cancelBubble 防止事件进一步冒泡

### 2. 地图拖动

md，konva 已经有拖动和放大功能的实现了：
https://konvajs.org/docs/sandbox/Canvas_Scrolling.html
https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html

问题
地图的底图比实际的 canvas 大小大很多，如果想显示完整的地图就有两种方式

- 创建一个和底图一样大的 canvas，然后通过 css 的滚动条进行移动
- canvas 大小固定，通过拖动的方式移动地图

第一种的问题：过大的 canvas 会导致性能出现问题，比如分辨率不足、渲染负担重等问题。
解决方式：canvas 大小固定，改变渲染区间。

具体做法：

- 首先创建固定大小的 canvas，然后把整个底图渲染上去。canvas 的大小不变，超出的区域是没有渲染的区域
- 实现拖动查看。具体功能点有
  - 基本的拖动，通过监听 mousemove 等事件，修改 canvas 的 translate，然后重新渲染，实现拖动效果
  - 边界控制，不能让拖动超出底图的范围，因此拖动时计算边界，如果拖动时 offset 超出边界范围就不发生移动。
  - 可视区域渲染：渲染所有点位时，先通过他们的坐标判断是否在可视区域，如果在才渲染，否则不进行渲染。

拖动的实现

基本思路：

1. 记录一个 offsetX 和 offsetY，表示 canvas 的 translate 值。每次绘制，都先`translate(offsetX,offsetY)`，然后执行绘制
2. 监听 canvas 的 mousedown、mousemove 和 mouseup 事件，当 mousemove 执行时，获取实时的鼠标坐标，和 mousedown 时获取的鼠标坐标的差值就是偏移量，即 offsetX 和 offsetY。
3. 通过修改之后的 offsetX 和 offsetX，如第一步操作。

另外：react-konva 中的实现：

- 其他方式基本不变，但是不需要自己手动绘制，只需要修改 layer 的 x 和 y 即可。

```js
const canvasRef = useRef < HTMLCanvasElement > null;
const mousePos = useRef([0, 0]);
const mouseOffset = useRef([0, 0]);
const currMouseOffset = useRef([0, 0]);
const scale = useRef(1);
const preScale = useRef(1);

// 检查点位是否在可视区域内
const isShapeVisible = (shapeX: number, shapeY: number) => {
  const [originX, originY] = mouseOffset.current;
  const [top, left, right, bottom] = [
    -originY,
    -originX,
    -originX + width,
    -originY + height,
  ];
  return shapeX >= left && shapeX <= right && shapeY >= top && shapeY <= bottom;
};

const draw = (type: TranslateType) => {
  // 绘制前先translate
  ctx.clearRect(0, 0, width, height);
  ctx.translate(mouseOffset.current[0], mouseOffset.current[1]);
  // ...
  // 点位的数组，每一项绘制之前先检查当前点位是否在可视区域
};

const onMouseMove = useCallback((e: MouseEvent) => {
  // 获取移动的量，即当前鼠标位置减去初始鼠标位置
  const moveX = e.clientX - mousePos.current[0];
  const moveY = e.clientY - mousePos.current[1];
  // 边界控制
  const [x, y] = mouseOffset.current;
  if (x > 1 || y > 1) return;
  if (x < width - backgroundWidth || y < height - backgroundHeight) return;
  mouseOffset.current = [
    // currMouseOffset用于记录已有的偏移，每次拖动理应在上一次偏移的基础上偏移
    currMouseOffset.current[0] + moveX,
    currMouseOffset.current[1] + moveY,
  ];
  draw();
}, []);

const onMouseUp = useCallback((e: MouseEvent) => {
  // 记录本次的偏移量，下一次就以curr为基础。
  currMouseOffset.current[0] = mouseOffset.current[0];
  currMouseOffset.current[1] = mouseOffset.current[1];
  canvasRef.current?.removeEventListener("mousemove", onMouseMove);
  canvasRef.current?.removeEventListener("mouseup", onMouseUp);
}, []);

const onMouseDown = useCallback((e: MouseEvent) => {
  // 设置一个初始鼠标位置
  mousePos.current = [e.clientX, e.clientY];
  canvasRef.current?.addEventListener("mousemove", onMouseMove);
  canvasRef.current?.addEventListener("mouseup", onMouseUp);
}, []);

useEffect(() => {
  if (!canvasRef.current) return;
  const canvas = canvasRef.current;
  const context = canvas.getContext("2d");
  draw();
  canvas.addEventListener("mousedown", onMouseDown);
}, []);
```

地图缩放实现：https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html

基本原理就是当 wheel 事件发生时，记录下来鼠标当前坐标，然后计算和原点的偏移量，除以旧的放缩比例。这个值乘新的放缩比就可以得到新的鼠标坐标在新的放缩后的画布上的位置。然后执行放缩，并将画布移动到新鼠标位置即可。

```js
var width = window.innerWidth;
var height = window.innerHeight;

var stage = new Konva.Stage({
  container: "container",
  width: width,
  height: height,
});

var layer = new Konva.Layer();
stage.add(layer);

var circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 50,
  fill: "green",
});
layer.add(circle);

var scaleBy = 1.01;
stage.on("wheel", (e) => {
  // stop default scrolling
  e.evt.preventDefault();

  var oldScale = stage.scaleX();
  var pointer = stage.getPointerPosition();

  var mousePointTo = {
    x: (pointer.x - stage.x()) / oldScale,
    y: (pointer.y - stage.y()) / oldScale,
  };

  // how to scale? Zoom in? Or zoom out?
  let direction = e.evt.deltaY > 0 ? 1 : -1;

  // when we zoom on trackpad, e.evt.ctrlKey is true
  // in that case lets revert direction
  if (e.evt.ctrlKey) {
    direction = -direction;
  }

  var newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;

  stage.scale({ x: newScale, y: newScale });

  var newPos = {
    x: pointer.x - mousePointTo.x * newScale,
    y: pointer.y - mousePointTo.y * newScale,
  };
  stage.position(newPos);
});
```

### 3. 性能优化

优化方面可以参考：
https://www.jianshu.com/p/a72b6d53c3f6
https://juejin.cn/post/7135229172409958431
https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas

性能优化过程

1. 测试阶段，发现在有些电脑上出现卡顿，拖拽和放缩过程不流畅，尤其是地图缩到最小，并且点开所有点位的详细信息时
2. 检查性能，通过 performance 工具，分别在我的电脑上和出现问题的电脑上进行测试，发现在性能不太好的电脑上，某些渲染过程的耗时达到 20 甚至 30ms 以上，超过了一帧
3. 分析卡顿原因：可能是绘制元素过多，计算过多
4. 了解优化方式：下面的内容，需要知道哪些是 konva 已经做了的，哪些是需要我们去做的

- 已经做的了：批量绘制、bufferCanvas 缓冲、优化指令
- 需要做的：分层、缓存、减少绘制物、整合数据

5. 优化效果：针对我们需要做的，做出优化，查看效果。效果主要体现依据是 performance 的绘制时间

- 分层：将背景图和点位分层。但是点位变化不大，效果一般
- 缓存：点位形状并不复杂，使用缓存优化效果不显著，反而内存占用上升
- 减少绘制：可视区域外不进行挂载，缩小时删除文本元素，初始比例放的比较大，绘制数量少。效果明显，每一帧基本小于 10ms 绘制时间
- 整合数据：将样式一样的图形合并并一次性渲染。效果不明显，因为 konva 底层已有类似的优化。

在拖拽和放缩基本功能的实现基础上，还需要保证 canvas 的性能稳定。性能问题要有针对性，并且有些性能优化其实在 konva 底层已经做了优化，我们需要知道哪些是 konva 做过的优化，哪些又是我们需要做的优化。

首先先列出针对性的优化方式

- 绘制方面
  - 减少绘制，包括减少绘制次数、可视区域外不绘制
  - 分层，把需要频繁绘制的部分创建成一个单独的层
  - 批量绘制，将绘制操作整合在一起，当短时间内触发重渲染时不进行渲染，而是整合到最后再进行渲染
  - 局部绘制，也称作脏矩形，这个比较复杂，相当于我们只会渲染需要变化的范围内的图形，将其通过一个包围盒包裹，然后和包围盒相交的其他图形也需要重新渲染。
  - 缓存/离屏渲染，将绘制结果缓存起来，再次绘制时采用 drawImage 重渲染。当被缓存的元素需要重新渲染时，也可以最大程度降低反复重绘的消耗。
  - 减少绘制物。除了拖动时不绘制可视区域外的元素，还可以在放缩到一定程度时，比如文字被缩小到看不见时，删除这些元素。
- 计算方面
  - 优化指令，避免不必要的赋值
  - 降低计算开销，比如计算点位，可以通过 webworker、raf 等方式降低计算过程的开销
  - 整合数据。比如要绘制几百个点位，有些点位的样式一致，那么就可以按照样式将这些点位分组，让这些样式相同的元素执行一次性的绘制。对 konva 来说其实就是把元素分组后，按照分组进行 map，这样每一组的 map 内部元素样式相同，减少了因为修改样式而造成的开销。

这其中大部分的基础优化内容都已经在 konva 实现了，我们能做的只有：

- 分层：把地图底图和点位分别绘制到两个层。当然进行变化的时候也需要同时对两个层操作
- 减少绘制物：可视区域外不渲染，缩小到一定程度不渲染文字
- 降低计算开销：优化算法结构。利用 webworker
- 整合数据：将样式相同的点位整合在一起，统一绘制
- 缓存/离屏渲染：需要通过 konva 提供的 cache 方法手动缓存

性能优化还要考虑的两个重要点，是如何检测性能，以及优化之后的表现如何。

对于 canvas 来说，最好的性能监测方式就是利用 profiler，即 chrome devtools 中提供的 performance 页。他可以监控页面上的任务执行事件；
我们可以在 performance 内查看页面的任务执行耗时。对于 konva 来说，draw 函数的执行表示整个画布的重绘，可以被看做是 canvas 绘制的时间消耗。

通过性能优化手段可以查看优化前后的 draw 函数耗时，是否超过一帧，以及初次渲染的耗时等等。

![](https://pic.imgdb.cn/item/64bed7e61ddac507ccd2645b.jpg)

### 4. 其他业内实现

这里的业内实现其实主要包含两部分

1. canvas 的业内实现，即 canvas 应用在其他方面的使用包含了一些业内的、成熟的实现及优化方案。

实现上，其实大部分的 canvas 库都已经做到了比较完备的实现，除了封装和事件系统外，也包含了一些基础的性能优化能力。
优化上，除了框架自带的之外，还有一些更高级的优化方式，比如离屏渲染、脏矩阵、分块加载等。这些都需要更进一步配合实现

2. 地图的实现。地图本就是一个很庞大的体系，对于前端来说，地图的业内实现主要有以下几种：

- 瓦片地图：一张大的地图或者背景图分成不同的瓦片，把这些瓦片拼接在一起，一个完整的地图就组合出来了。瓦片地图金字塔模型是一种多分辨率层次模型，从瓦片金字塔的底层到顶层，分辨率越来越低，但表示的地理范围不变。
  比如我们放大地图时，相同区域的瓦片会越来越多，分辨率也会越来越高，相当于瓦片分的越来越细。
  前端实现瓦片的库是 Leaflet.js。用 Leaflet.js 实现的瓦片地图其实本质上是图片的加载，当我们放缩地图时，他可以控制请求可视区域内的瓦片，然后重新渲染显示。

如果考虑到 canvas 实现，其实就相当于我们要在 canvas 内实现一个类似瓦片加载的效果。比如对于地图的底图，我们可以通过瓦片库的生成结果（包含瓦片图片和坐标信息），对照实际的 canvas 坐标系通过 drawImage 渲染不同的地图。当放缩移动事件发生时，在重新计算瓦片并请求。

参考：https://segmentfault.com/a/1190000040678481
https://www.cnblogs.com/lishanyang/p/14290162.html

- 可视区域渲染，这个就是上面说的，当放缩小于一定比例后隐藏。

## 其他注意点

1. 移动端？

如果项目是在移动端的，可能需要什么样的操作使得地图可以在移动端正常使用？

- 响应式：由于移动端屏幕大小不同，因此 canvas 大小可能需要改变
- 性能：移动端性能可能不如 pc 端，因此需要考虑更多的性能问题，比如 web worker 等，以及 canvas 的一些优化方式
- 操作：移动端操作事件和 pc 端不同（比如 touch 事件和 mouse 事件），需要做出适配
- 地图加载：可以采用压缩、地图分块加载等方式加快地图加载速度，这个也适用于 pc 端

2. 定位到机器人的问题

还需要一个功能：把地图中心点定位到机器人的位置。核心其实还是通过控制 translate

3. 部署？

项目是怎么部署的？（这个可能有点来不及了）

4. 长连接的方式

除了轮询和 websocket，还可以怎么样保持地图的实时性？

- SSE：SSE 是一种基于 HTTP 协议的单向通信机制，它允许服务器向客户端推送事件流。客户端通过建立一个持久化的 HTTP 连接，从服务器接收事件数据。
  SSE 通常适用于服务端推送少量数据给客户端。
  SSE 的使用类似 websocket，但他发送数据的单位是事件流，即服务器端发送的响应内容应该使用值为 text/event-stream 的 MIME 类型。每个通知以文本块形式发送，并以一对换行符结尾。

```js
const evtSource = new EventSource("//api.example.com/ssedemo.php", {
  withCredentials: true,
});
evtSource.onmessage = function (event) {
  const newElement = document.createElement("li");
  const eventList = document.getElementById("list");

  newElement.innerHTML = "message: " + event.data;
  eventList.appendChild(newElement);
};
```

- 长轮询，不过不适用于本项目。

5. 项目中替换技术栈有什么工程化的方式？

- 渐进式替换，新的组件用新的技术栈，旧的组件用以前的
- 做好自测和 QA 的测试

6. 性能问题，主要是初次渲染、更新重渲染和拖拽、放大事件的性能问题考虑，尤其是最后一个。

实际上 konva 已经在内部做了很多性能优化


# 特价团购项目

难点：

- 轮播组件的开发。由于项目的未来扩展性（可能跨端），因此不能使用现成的 rn 库或 web 端库，只能依赖自行开发轮播组件。参考现有轮播组件的逻辑进行开发和设计

轮播组件参考为：https://github.com/meliorence/react-native-snap-carousel

- 轮播组件是怎么实现的，实现关键点，难点
- 轮播组件的优化
- 轮播组件嵌入视频，主要有
  - 视频的单例。只在页面上放置一个视频组件
  - 视频组件放置在轮播图中心，通过 z-index 控制显隐。轮播图滚动时，控制视频组件更换源，加载完成后显示。主要是放置重复销毁创建的消耗
- 页面性能优化
  - 会场页首页由于引入了视频和轮播图，导致加载速度变慢，并且出现视频闪烁的情况
  - 其他页面 RCF 指标偏低，尤其是 C 指标时间很长，会场页甚至达到 3000ms 以上。
  - rn 的优化方式和 web 端不同，应该采取更好的方式进行优化

技术栈：rn、mrn

## STAR 总结

项目有两个需求，因此有两个 STAR 总结内容

### 轮播图

1. S：背景。

需求背景：根据项目需求，需要在首页轮播展示商品。同时还要加入视频功能，即轮播图上需要展示视频，当滚动到中间位置时播放该商品的宣传视频
技术背景：mrn 架构下，轮播图不能直接引入 rn 库或 web 库，并且内部组件库的轮播组件不符合要求，需要自己开发轮播组件，并对视频组件的接入做一定的支持。

2. T：目标

完成轮播组件的功能实现，可以实现自动轮播、无限循环、手动滚动等功能，同时做到基本的轮播组件优化
完成轮播视频的接入，能正常播放视频，并且能在轮播组件切换到下一个之后及时卸载其他视频组件，保证页面上同时只有一个视频组件

3. A：行动

基本轮播图的实现：学习了解轮播图的关键功能点实现方式，创建组件实现。
实现关键点：

- 基本容器：采用 FlatList 作为滚动部分的基本容器，考虑到兼容性也提供了 ScrollView 的替换
- 基本功能：
  - 轮播图尺寸：确定的两个关键参数：itemWidth 和 slideWidth，要求 slideWidth 需要是 itemWidth 的整数倍，并且 itemWidth 起到确定每个轮播图位置的作用
  - 轮播图位置：通过 positions 数组，初始化时根据 itemWidth 计算每个轮播图的起始、结束和中心位置的偏移量，第一个轮播图的偏移量为 0，依次类推
  - 切换图片实现：分为滚动切换和自动切换两种
    - 自动切换：已知每个轮播图的位置信息，那么 snapToItem 方法可以传入一个指定的 index，根据 index 获取指定轮播图的中心位置的 offset，再使用 scrollToOffset 滚动到该 offset 即可。（为什么不用 scrollToIndex？因为 loop 需要添加额外元素，toIndex 不准）
    - 滚动切换：触摸滚动事件发生时会触发几个事件：onScrollBeginDrag、onScrollEndDrag 和 onScroll。这三个事件内部分别做的操作为：
      - onScrollBeginDrag：记录开始移动时的 offset 和 activeItem，暂停自动播放
      - onScroll：实时计算 activeItem 并更新全局的 activeItem，如果发生切换，即当前的 activeItem 不等于开始时记录的，就触发回调
      - onScrollEndDrag：根据 activeItem 滚动到指定的 activeItem 上，触发回调，回复自动播放
    - activeItem 计算方式
      1. 首先确定当前的中心偏移量 center，即 offset+sliderWidth/2
      2. 确定当前的范围，即`[center - activeSlideOffset, center + activeSlideOffset]`
      3. 二分查找 positions 数组，确定一个 start 在这个范围内的元素，也就是第一个 start 比 center - activeSlideOffset 大的元素，就选定为 activeItem
  - 循环滚动实现：基本实现原理是在轮播图两边加上一定数量的元素，当滚动到额外元素之后，使用一个不带动画的 scrollTo 迅速滚动到对应的原位置。除了这个实现之外，还加入了 loopClonePerSide 实现：
    - loopClonePerSide 实现：为了解决快速滚动时出现滚动到边缘的情况，在轮播图两边加入一定数量的元素，防止快速滚动时看到空白。实现关键：
      - 加入顺序：在前和后都加入，前面加入的是从后向前的 slice，后面加入的是从前向后的 slice
      - 确定索引：因为加入的元素是真实的元素，因此需要真实索引和组件内索引的映射。
        - 真实索引 -> 组件内索引：直接加上 loopClonePerSide，表示前面加了这么多个元素
        - 组件内索引 -> 真实索引：根据值确定，比如 `< loopClonePerSide`时表示在前半部分的虚拟位置上，对应到真实位置；后半部分同理
      - 滚动逻辑的修改：在 onScroll 内计算 activeItem 时，通过索引找到的 index 通过映射改为真实索引。当触发 onScrollEndDrag 时，如果此时的 activeItem 不在真实范围内，就触发无动画滚动到真实索引。
  - 自动播放实现：一共有三个内容，分为开始播放、暂停播放和停止播放。维护两个全局状态，isAutoPlay 表示是否有自动播放的根本来源，即 props，如果没有就不会启动定时器；isAutoPlaying 表示是否正在播放
    - 开始播放：判断 isAutoPlay，如果可以播放就启动一个 setTimeout，延迟设置的秒数后通过 setInterval 开启自动播放。这两个定时器的 timeout 都放在全局
    - 暂停播放：清除两个定时器的 timeout
    - 停止播放：调用暂停，同时 isAutoPlay 设置为 false，之后再不会播放
- 优化能力：
  - FlatList：主要采用了 FlatList 本身带有的优化，设置相关参数
    - visibleItems：确定可视几个元素（不是 FlatList 属性），项目中是 3 个
    - initialNumToRender：visibleItems + loopClonePerSide _ 2，比如初始只渲染 3 + 2 = 5 个，如果开启 loop 的话就会渲染 3 + 2 _ loopClonePerSide 个。一般 loopClonePerSide 设置为 3 就可以保证不会出现空白，因此初始化最多渲染 9 个
    - windowSize：2 \* initialNumToRender + 1，参考官方文档的建议设置
    - removeClippedSubviews：作为一个保留项。如果在 FlatList 上渲染有问题，就关闭这个选项
    - getItemLayout：根据元素位置返回
  - 控制元素数量：限制 loopClonePerSide 的个数，默认为可视区域内元素个数，项目中是 3 个
  - React.memo 处理轮播组件

轮播视频的实现：
首先考虑了不同的实现方式：

- 将视频固定，切换轮播图时隐藏，切换完成后设置源，显示播放；
  - 优点：只维持一个组件，维护心智负担小，方便
  - 缺点：视频不能跟随轮播图滚动，轮播图滚动时容易漏出下面的部分
- 将视频跟随轮播图元素，切换时卸载组件
  - 实现：当 onScroll 事件发生期间会检查 activeItem，如果发生变化会触发 onActiveItemChange，然后就可以控制上层的的 state 改变，卸载组件。当滚动停下来后，再确定新的 activeItem，挂载视频并播放。
  - 其他：
    - 切换到视频时会先展示封面，开始播放时再隐藏封面
    - （可能）当切换到某个元素时，对前面和后面一个元素的视频或封面图进行懒加载。视频可能不行，但封面图应该可以

其他细节实现：
如何控制视频元素的 active 在 renderItem 函数内

```jsx
export default function CarouselContainer(){
  const [activeIndex, setActiveIndex] = useState;
  const carouselRef = useRef(null)

  const renderItem = useCallback(({item,index}) => {
    const isActive = carouselRef.current.getRealIndex?.(index) === activeIndex;
    return (
      <Card isActive={isActive} {...} />
    )
  },[activeIndex])

  const onSnapToItem = (index) => {
    setActiveIndex(index)
  }

  return (
    <Carousel ref={carouselRef} renderItem={renderItem} onSnapToItem={onSnapToItem} data={data} {...} />
  )
}
```

如下所示，当调用 setActiveIndex 修改当前 active 的 index 时，CarouselContainer 组件会更新，renderItem 函数会更新，触发整个 Carousel 更新，在数据没改变的情况下更新渲染条件，让处于 active 的 card 挂载视频并播放。
这个地方有两个细节：

- renderItem 的参数 index 并不是真实 index，如果开启了 loop，那么就是组件内的 index。我们可以暴露内部的 getRealIndex 方法，传入这个 index 返回新的 index。
- 每次 activeIndex 更新后，整个 Carousel 都会重新渲染，但这是无法避免的。为了尽可能保证性能，要保证一些点：
  - CarouselContainer 组件渲染尽可能少；
  - Carousel 组件内部用到 memo 比较
  - Card 组件用好 memo，每次更新时最多只是重渲染两个 Card 组件，即 isActive 属性改变的两个 Card，其他 Card 不会重渲染。

4. R：结果

实现了轮播图，能成功轮播元素，实现循环滚动等效果
实现了视频，能成功播放对应元素上的视频

不足的点：

- 轮播图依赖 FlatList、ScrollView 等实现，优化方式也依赖于 FlatList。如果想要在 web、小程序等方面实现，就需要考虑其他解法
- 轮播元素组件本身很复杂，并且还会包含视频，初始渲染时间会挂载一定数量的组件，如果数量多必然会受到影响。

5. 其他关键点

项目相关的技术要点：

- React 重渲染优化
- FlatList 和 ScrollView 的属性、用法、props
- 虚拟列表的原理

### 优化

1. S：背景

- 线上 RCF 指标偏低。公司内有针对 c 端页面的 RCF 指标监测，分析发现我们的多个页面评分都偏低，优化重点为评分最低的几个页面，主要为会场页和商详页。
  优化前会场页 C 指标得分为 3 分，商详页得分为 20 分。会场页加载时间约为 3000ms，商详页为 1500ms
  优化前的预测原因：
  - 会场页：包含组件很多，模块比较多，同时有轮播图、列表等渲染消耗比较大的组件
  - 商详页：同理模块较多，但首屏模块只有少数几个
- 测试时发现一些问题，比如闪烁、加载缓慢
  - 页面滚动时轮播图会发生闪烁
  - 点击 tab 吸顶时会发生卡顿，点击后会明显感觉卡一下才会吸顶

优化指标背景：

- RCF 指标：
  - R：响应时间，主要是从用户触摸事件开始到页面做出第一帧变动的时间，主要依赖 native 测算。大致原理是“追随”点击事件的流转，直到点击事件被 JS 消费并且点击事件修改的布局在 UI 线程完成更新的时间。
  - C：首屏加载时间。统计方式是从页面启动、native 代码加载开始，一直到 js 完成渲染、元素稳定为止。
    > C 指标实际取的是 FSP，即首屏渲染时间，这个值是由开发者手动上报的。
    > 如果不上报，则采取类似 fmp 的方式，在 shadowThread 监听，当有节点变动时判断是否是首屏节点，如果是就刷新时间。直到最后一个变动结束 n 秒后统计完毕。这个过程不涉及权重计算，而且统计的是最终完成加载的时间，因此和 fmp 也不完全相同。
  - F：实时帧率，主要是页面帧率，会考察最大连续丢帧的情况
- 其他指标
  - mrn debugger 提供的功能
    - 首屏加载时间
    - 包体积计算
    - 页面帧率
  - profiler
    - 火焰图重复渲染检查
  - 秒开率：页面在 1s 内渲染完成首屏的次数 / 打开的总次数。秒开率是线上指标
  - 跳变次数：线下指标，表示页面已渲染的元素发生位移的次数
  - FCP、FMP、TTI：线下指标，主要通过录屏工具测算

2. T：目标

- 优化目标：会场页加载耗时减少一半以上，商详页降低至 1000ms 以下；得分达到 40 分以上
- 解决测试发现的性能问题

3. A：行动

首先是优化会场页和商详页的 c 指标，即首屏加载速度
优化手段主要有：

- **代码分割**，通过 RAMBundles + InlineRequire 进行代码分割，将庞大模块分离出去减小包体积。具体细节有：
  - 分割的对象
    - 可能不在首屏加载的模块，需要懒加载的模块。项目中是**商详页的猜喜、榜单**。这些模块采用懒加载，当他们进入可视区域时才会加载，因此需要对他们进行分包。即使这些模块有可能在首屏，但我们仍把它们看做是非核心模块，然后进行懒加载就行。
    - 没有数据就不展示的模块，项目中是**三种不同专区**都可以分离，主接口包含专区数据时再加载和渲染。
      > 这里有一个问题：如果该模块没有数据，但是该模块属于首屏模块，那么有可能出现首屏其他元素都加载了，然后这个模块才开始加载，最后突然出现影响布局。但是实际上这里并不会造成很大的延迟，因为 require 本身是同步的，当有数据时直接同步执行代码就可以；但是如果在 web 端，通过异步加载就要考虑这个问题。为了避免这种情况，项目中没有把可能严重影响布局的模块分离（顶部的专区不做分离），而加载在下方的、不会引起巨大偏移的模块，可以继续这样使用
    - 需要用户手动触发的模块，项目中就是**手动触发的 Modal 弹窗**。可能会一进入就弹出的弹窗按照第二条处理
  - 分割方式
    - 在项目配置文件中开启`indexedRAMBundle: true`
    - 对要分割的模块，从入口开始，删除 import 导入，替换为 require 语法。通过 useEffect 在指定时机执行 require 导入。
    - 添加预加载设置，按照官方配置要求，把首次加载就执行导入的模块加入黑名单，进行预加载
- **包体积缩减**，主要是优化包内使用的库。优化方式主要包括：
  - tree-shaking 的保证？
  - 大型依赖的治理，即对于 lodash、moment、组件库等大型依赖要进行缩减
    - 将 debounce、deepClone 等方法转移到内部库引用，内部库有良好的 tree-shaking 支持，配合 babel-plugin-transform-imports 可以基本实现最小导入。该插件简单原理参考[这里](https://segmentfault.com/a/1190000010787241)
    - 接入并使用 babel-plugin-transform-imports，对导入代码的导入路径精细化设置
    - Icon 的图标优化。icon 组件使用时可能会全量引入表示 icon 的图片或 svg，解决方法主要有两个
      1. 将项目中实际用到的 icon 单独导入到一个文件内，其他模块从这个文件内导入。参考[这种写法](https://blog.csdn.net/jc8189533/article/details/115492777)
      2. 使用 babel 插件，在编译 icon 时，将 icon 的 type 修改为具体路径的 require 函数。这样组件内部直接通过调用函数获取到实际的资源，而不是全量引入。
         > 关于 icon 的实现和按需加载，还有很多可说的地方，这里仅选用第二种方法就可以
- **渲染优化**。渲染优化在项目中主要体现于首次渲染时尽可能降低消耗。由于 rn 的渲染是通过 bridge 异步通信完成的，因此优化的主要方向是降低通信数据量，提高通信速度来加快渲染。具体渲染优化方式为：
  - 分批渲染：抽象出渲染优先级控制组件 Priority，根据优先级对页面不同元素进行渲染。具体方法为：
    - 会场页：**核心组件**，即专区和列表的渲染优先级最高，其他的组件，如 tab、导航栏、搜索框等优先级低于核心组件。
    - 商详页：按照页面布局从上至下的顺序设置优先级。这类布局规律的页面都可以这样做
      此外，还有一些需要考虑的问题：
    - **意义**：分批渲染的意义在于，bridge 使用 message 队列进行异步通信，需要控制异步消息的发送时机；同时需要控制数量，防止同时渲染大量消耗比较大的组件在低端机上导致性能降低。
    - 模块渲染完成的时机：不同组件对渲染完成的定义不同。如果只在 useEffect 内调用，某些组件可能并未完成渲染，比如网络请求还未完成、图片还没加载完成等。因此 Priority 组件向子组件传递一个方法，可以主动调用下一优先级的组件开始渲染。比如在列表组件内，列表项请求完毕并设置 data 之后才会调用，商详页的商品大图则会在图片加载完成后再调用。
  - 延迟加载和渲染：基本是通过代码分割的方式。内联导入也提供了延迟渲染的能力
  - 减小代码层级：即 jsx 代码降低嵌套，多通过 Fragment 来包裹元素，将方法监听等 props 集中到较顶层的 View 上
- **网络请求优化**。主要针对二级页的处理，比如从会场页跳转专区页、从会场页跳转商详页等。
  - 请求前置：请求前置实际上是在跳转的同时发起请求，并不等同于完全的预请求。但是考虑到页面从点击跳转到显示还有加载 jsBundle、jsRender 和 nativeRender 等阶段，请求前置仍然可以提前一定的时间，但很难达到直出效果。
  - 跳链优化：在跳链内携带一些数据，比如会场页到商详页的跳链会携带商品头图的 url 以及商品的基本信息，可以少请求一次
  - 缓存优化：以会场页跳沉浸页为例，当会场页获取专区数据后，会将数据缓存，沉浸页进入时则会取缓存，如果缓存失效或数据为空则兜底请求。不过这里要考虑的很多，比如缓存失效时间、缓存刷新、重复请求等问题。
- 其他优化，比如预热容器、图片根据大小请求、轮播图初始渲染元素个数优化等。

然后是一些针对具体问题的优化

- 页面滚动时轮播图闪烁问题。
  1. 初步猜测是由于频繁刷新导致的，但不清楚具体是什么原因、什么位置
  2. 使用 wdyr 检查。从下至上检查，从轮播图卡片开始，-> 轮播图组件 -> 轮播图父组件 -> 专区组件 -> App 组件
  3. 在检查轮播图父组件时，发现并没有 props 引起的重渲染，但有 useSelector 导致的重渲染，检查发现使用时直接 select 了整个 list，然后在页面滚动时修改了 list 的 offset 属性，从而导致组件更新。
  4. 解决方案：
  - 将页面滚动的数据传递替换为全局 EventBus 的形式，数值直接修改到对应组件的 Animation 上，不会经过 state
  - 检查项目中各处使用 useSelector 的地方，保证 selector 的引用最小粒度
  - （更多）考虑使用 createSelector 来优化，详见 react-redux 部分
- 吸顶操作时感觉卡顿。
  1. 初步分析吸顶操作时的步骤分解：
  - 点击 tab
  - 滚动吸顶
  - 显示其他部分
  2. 按照步骤逐个排除问题：
  - 点击 tab，检查点击 tab 之后执行的部分，检查其他调用，注释掉其他调用再观察，发现如果不吸顶的话不会卡顿
  - 手动吸顶，发现吸顶的一瞬间展示了券列表，发生了卡顿，猜测可能是在券列表问题上
  - 使用 profiler 检查吸顶瞬间的任务执行情况，发现券列表组件渲染时间长达 370ms，检查发现是 scrollView 渲染过多元素导致。但是页面显示的券只有三张，因此可能是由于不可见元素大量渲染导致
  - 检查券列表组件，打印数据发现存在空数据，即除了正常显示的券之外还有大量冗余数据。这些数据会导致渲染大量位于屏幕外的、重复的券，而一开始的设计仅是处理少数券的情况，因此没有采用 FlatList。
  3. 解决方案：反馈后端同学解决数据冗余问题，同时在组件内做好 data.slice，确保显示数量不会过多。

4. R：结果

结果主要是优化结果，不同的优化手段得到了不同的性能优化结果。

- 首屏加载时间优化（测算数据为中端机）
  - 会场页：首屏加载时间从 3000ms 降低到 1800ms 左右，c 指标提升到 30 分。具体步骤：
    - 代码分割：最明显，从 3000ms 降低到 2000ms 左右
    - 包体积缩减：加载时间效果不是很明显，但是对 icon 组件优化后通过包体积分析，明显得出主包体积减小，压缩包体积减少了 100kB（不明显原因：mrn 已经做了很多压缩和精简，并且原本代码中已经对依赖保持较好的引用，不存在过大依赖）
    - 渲染优化：没有影响首屏加载时间，但通过 RN debugger 调试工具，可以得出每个模块的渲染时间，得到核心模块渲染耗时相比于优化前减少了约 200ms，相应的非核心模块渲染耗时则略有提升。
  - 商详页：使用预加载和请求前置后加载时间从 800ms 降低到 600ms，设置猜喜模块、榜单模块的懒加载后降低到 400ms
- 性能问题得到解决：测试出现的卡顿、闪烁问题均得到解决，页面流畅度提升。

5. 其他

优化问题相关知识点：

- rn 的全部内容，尤其是优化方面，还有渲染原理等
- redux 的优化，useSelector
- web 优化方案、h5 优化方案等，从 rn 扩充到移动端、跨端优化方式，以及基础的 web 优化指标等等

目前想到的可能会有的扩展知识点：

- 跨端，其他跨端方案，跨端的基本原理和方式，跨端的优化方式
- 移动端开发的注意事项，移动端的常用优化，比如端内 h5 这种
- 性能监控和错误监控的方案
- 性能指标的采集方式，在跨端上的采集方式
- 一些非常规的优化手段，比较专项的方案。以及更多没有在项目中实际应用的方案，比如深度预加载、页面直出等等。这些内容需要多看一些技术文章来应对
- profiler、performance、memory 等调试工具的具体使用细节
- webview
。

### 页面加载流程分析

以会场页为例，当用户从美团首页点击进入特价团购时，从观感上的流程如下：

1. 一个菊花屏的加载中，尤其是首次加载时事件会比较长
2. 骨架屏，大概有 2-2.5 秒，并且受网速影响不算很大
3. 一小段白屏，在骨架屏消失和 FCP 之间还有一小段白屏
4. 正式组件的渲染，携带具体数据，按照一定的优先级，当前情况为轮播图 -> 列表 -> tab -> 其他
5. 图片加载完成，icon 加载完成，页面整体完成。

这里延伸出几个问题。

1. 菊花屏：主要是容器的启动时间。如果后台杀死程序再启动，菊花屏就会花比较多时间；如果美团 app 一直在线，那就不会花太多时间
2. 骨架屏：

- 首先骨架屏本身不是 js 渲染的结果，而是跟随包一起的、由 native 直接渲染完成的，因此即使没有网络也会显示一瞬间骨架屏，同时在 js 还没开始执行就已经能显示骨架屏了
- 骨架屏背后，其实是页面的白屏。如果把骨架屏去掉，那么还是会有相等时间的白屏，说明在这段时间内完全没有进行任何渲染，而第一次渲染就是携带数据的，并且能受到分步渲染的控制，因此可以理解为组件的的 componentDidMount，而非 Update。
- 这个白屏期间主要在干什么呢？根据流程，主要工作应该是：jsbundle 的下载和增量更新（首次）、jsbundle 的解析、jsbundle 的执行、主接口的请求，当请求结束后就会控制骨架屏消失。然后所有的组件开始初次渲染，并且此时是携带数据的

3. 一小段白屏：主要是渲染所有组件的时间。骨架屏消失的时机是主接口返回数据，从这里到组件完成渲染还需要一段时间。这也是渲染优化的主要作用点，如何在这一段时间内尽快把核心内容渲染出来
4. 正式组件渲染：按照优先级依次渲染，观感上就是显示是有明显的次序的。

有一个想了一晚上的疑问点：
按理来说，接口数据和渲染的关系应该是 jsbundle 执行 -> 组件 render -> 组件 useEffect -> 请求业务接口 -> 返回数据并更新 -> 组件 rerender
也就是说在骨架屏背后的时间里，应该是完成了一次渲染的，主接口返回时是重新渲染；
但是实际情况是并没有，去掉骨架屏的话就是白屏，并且后续的渲染明显是首次渲染。

后来解释清楚了，具体可以看下面难点里《关于骨架屏和初次渲染的关系》，其实就是当主接口没返回数据时，业务组件都还没被挂载；只有主接口返回正常数据（不为null或者不报错）时才会渲染，因此对于业务组件来说其实都是首次渲染，并且是带上初始数据的

*一小段白屏*其实就是业务组件初始化渲染的时间，从骨架屏消失到组件渲染并显示还有一段时间。因此分步渲染、按需渲染都是在优化这个过程。



### DMAIC优化思路分析

按照 DMAIC 的优化思路来考虑。
注意：如果问到如何做优化，那么按照下面的来说就是最好的，也就是说有一个大概的发现问题、提出方案和解决问题的流程，而不是上来就是应用一大堆优化。

#### Define

Define: 定义优化的方向和目标

- 方向：
  - 首屏加载速度提升
  - 首屏体验提升
  - 部分闪烁和卡顿问题解决
- 具体目标：
  - C 指标评分从 2 分提升到 20 分左右，综合指标提升从 40 分达到 60 分
  - 首屏加载时间，通过`RACF 指标线下测试 SOP`的方式（相当于在线下测试 racf，主要是为了检查变化，不一定准确）
    - 优化前：
      - 安卓中端机 3500ms
      - ios14 2400ms
      - 线上值：3000/3200/3500
      - 注意：ios 比安卓要好很多，因为 oc 的代码比 java 效率高一些
    - 优化目标
      - 安卓中端机：2500ms
      - ios：1800ms
      - 线上：平均 3000ms 以内

#### Measure

Measure: 测量性能

测量的对象：

- 线下的首屏加载时间，以测试机型为准，主要方便查看变动
- 各阶段的具体加载时间，方便针对性优化
- 包体积、包结构

测量的结果：

- 整体加载时间：以一个机型为标准，测试 C 指标时间为 3500ms
- 具体的各个流程的加载时间。线上数据只有一个整体的加载，并没有细粒度的各流程时间。可以借助 mrn 的调试工具来测试各个流程的加载时间，大致占比为：
  - 容器创建、引擎创建：3.5%
  - jsbundle 下载&解压：1%
  - 业务包编译、解析：10%
  - 业务包执行：30%
  - 首要素渲染（App 组件 render，启动网络请求，暂未渲染业务组件）：10%
  - 网络请求：30%
  - 首屏渲染：15.5%
- 包：
  - 包体积：不同页面的包不同
    - 会场页：约 980KB
    - 商详页：约 350KB
  - 包结构：通常的 bundle = index.js + Assets + 其他配置文件
    - 会场页：
      - index.js: 业务代码综合包，1.2MB（解压后）
      - Assets: 各种静态资源，比如骨架屏、字体、部分 icon 图片，200KB
      - 其他：40KB
    - 商详页：
      - index.js: 280Kb
      - 静态资源：20KB
      - 其他：30KB

后续主要关注点：

- 首屏加载时间的提升百分比，在测试的安卓和 ios 上的结果，以及在线下 SOP 的测试结果
- 流程里，重点关注业务包的解析执行时间、首屏渲染时间，让这两个的时间占比降低

#### Analyze

Analyze：分析原因，找出解决方案

针对问题，先考虑尽可能多的导致原因，然后调查、分析来排除；针对每个原因，再想尽可能多的解决方案，再去根据实际情况选择合适的方案。

1. 分析潜在原因：

- 包解析执行过程占比时间较长
  - 猜测是由于包体积比较大
  - js 部分未做代码分割，部分内容可能全量引入
  - 未做预加载
- 网络请求时间占比很高：
  - 未做预请求，请求在 js 执行之后才开始
  - 未利用到缓存，每次进入首页数据都完全重新请求
- 业务组件渲染时间较长
  - 组件未做分级渲染，同时全量渲染导致核心组件渲染速度慢
  - 组件未做懒加载、懒渲染
- 页面滚动轮播图闪烁问题
  - 重复渲染，可能是滚动事件绑定了某个状态更新
- 点击 tab 页吸顶卡顿问题
  - 点击 tab 的事件和后续执行了大量计算或阻塞性的代码
  - 点击 tab 之后大量同时执行了渲染启动任务
  - 点击 tab 之后导致列表或其他部分的的全量重渲染

2. 分析之后，需要测试原因到底是什么，预想的潜在原因是否真实

- 包解析执行时间问题：
  - 包体积大小：980KB，确实相对偏大
  - 包结构：js 部分占到 1.2MB，并且项目中未做任何代码分割的内容。
  - 不存在预加载内容
- 网络问题
  - 通过网络调试面板，每次进入都会重新全量请求，没有缓存；
  - 通过调试面板的请求时间比较，发现请求时机被放置在 js 解析之后，并没有在 native 进入时就做预请求
- 渲染问题：
  - 通过录屏逐帧查看，所有模块在瞬间被同时渲染出来，包括导航栏、浮标等不太关键的模块
  - 在商详页，猜喜模块默认进入就会渲染。
- 页面滚动问题：
  - 找到页面滚动事件监听，去掉所有监听的回调，再测试不存在闪烁问题
  - 使用 wdyr 从下至上测试轮播图卡片、轮播图、轮播图父组件和专区组件，在轮播图父组件发现了重渲染是来自 useSelector 不正确的引入
- 吸顶卡顿问题：
  - *卡顿*的测试方式：点击 tab 到吸顶结束，通过 profiler 录制查看是否存在渲染时间过长的任务
  - 按一定规则分析：
    - 删除 tab 点击事件回调，点击 tab 不会卡顿，但吸顶之后发生卡顿
    - 删除吸顶回调，没有出现卡顿
    - 控制券包和列表渲染，发现在券包渲染时会出现卡顿
  - 发现到券包每次吸顶都会产生 300-400ms 的渲染耗时

3. 然后就是分析解决方案。同一个问题的解决方案有很多，应该根据实际情况选择最合适的。

优化方案分为两个阶段

- 第一阶段先解决明显的性能问题（卡顿闪烁等），其他问题采用较低成本优化的方式，进行初步优化。选择的优化方式有
  - 优化包体积，包括删除一些库、引入 babel 插件、组件库单个安装和引用、替换旧库等
  - 配置预请求，将会场页主接口请求提前到用户点击进入的时候，即容器加载的时候
  - 对部分模块进行按需渲染，比如商详页的猜喜模块，进入可视区域才请求并渲染列表
  - 其他细节优化，比如轮播图控制渲染数量、离屏销毁等
- 第二阶段建立精细化的打点方案，统计性能瓶颈，再做专项优化，可能会存在一些高成本的方案
  - 用 RAM+require 进行代码分割，需要确定要分割哪些模块，并且优化代码结构来方便分割。
  - 优化分步渲染，对会场页和商详页的组件制定优先级，使用 Priority 来优化
  - 接入普通预加载，在会场页加载稳定后，开始对用户流向较多的商详页和专区二级页进行预加载

#### Improve

improve，就是实际去做，并且在做的过程中要统计并测试，查看效果。

根据在 Analyze 阶段确定的方案，优化分为两个阶段。

1. 初步低成本优化：

- **优化包体积**：大部分检查工作由 cli 完成，debug 工具和可视化 bundle 也能分析依赖的引入次数等数据
  - 通过 cli 的功能，删除部分重复引入、没有用过的依赖，并发现一些版本较老的库进行替换
  - 部分库替换为原生编写，比如事件总线用到的 Pubsub 库，替换为编写的全局 EventEmitter，因为仅使用部分功能
  - 组件库优化导入，接入 babel-plugin-transform-imports 来优化。部分组件和某些模块（比如 KNB）只引入了一个，就不全量下载
- **配置预请求**：直接配置，把会场页请求前置。主要工作其实就是编写一个 json 文件，在编译时该文件会被处理去做预请求内容。
- **按需渲染**：通过内置组件 MCModule 的按需渲染能力来做。原理和 web 上类似，检测进入可视区域就渲染。主要处理的内容包括：
  - 商详页的猜喜模块、评分模块等
- **其他优化**：优化了轮播图初始渲染数量（3+2），优化了轮播图的结构（用图片和兜底色来替换较为复杂的 jsx 结构，比如把 LinearGradient、Tag 等替换成图片，利用图片缓存来优化）

2. 较高成本优化：

- **代码分割**：通过 RAM+require 进行分割。RAM 的配置比较简单，关键是如何配置 require 的位置，以及需要做完善的测试，防止出现加载问题。
  - 具体工作：
    1. 首先配置 indexedRAMBundle: true
    2. 设置 require 的位置和加载方式：
    - 数据驱动加载：专区模块、直播模块等，当首页接口返回值不为 null 时才执行 require 去加载
    - 弹窗：弹窗分为用户操作弹窗和首屏进入的弹窗。对于首屏进入弹窗采用和专区相同的优化方式，根据弹窗接口的返回情况来主动加载
    - tab 页：商品列表页，除了第一个 tab，其他 tab 都是点击 tab 之后才加载。tab 数量是固定的
    3. 代码优化：将组件细化，部分只在某个组件内使用的依赖可以考虑单独开一个组件，然后将依赖放入，再对这个组件进行分割。不过比较理想化，实际并没有做很多修改
    4. 输出并确定首屏需要加载的模块，然后将其加入黑名单，保证首屏加载的模块不会被分割
  - 其他工作：
    - 测试：每分包一部分模块就 mock 数据来测试是否能正常显示
- **分步渲染**：利用 Priority 组件，将核心模块设定优先级。注意划分的对象应该是上面分割之后，在首次就加载的模块。也就是说这里操作的对象模块和上面分割代码的模块不冲突，这里设置的一定是上面没有 require，而是默认加载的。
  - 具体工作：
    1. 确定核心模块的范围和优先级的值。
    - 采取了推荐的方法，即划为 high/normal/low 三级
    - 承载主要数据的为 high，包括轮播图和列表。根据业务特点定义“核心”
    - 其他的比较重要的占位元素为 normal，比如 nav、一级 tab
    - 剩下不会造成大的布局变动，并且大概率不在首屏的，设为 low，包括浮标、二级 tab 等
    2. 考虑更具体的情况
    - 什么时候可以确定一个组件“渲染完成”然后“可以渲染下一个优先级”？
      - 默认采用连续的方式，即 PriorityComponent 包裹目标组件；PriorityComponent 内的 useEffect 执行时，目标组件内的 useEffect 一定是已经执行过的，可以看做是目标组件已经完成渲染。多个 PriorityComponent 内的 useEffect 依次执行，就可以形成连续渲染的方式。也可以添加一个 delay，让每个渲染之间延迟一定时间；但提供了一个 props，为 true 时才会渲染下一个
      - 由于作用对象是首屏渲染内容，这些内容在渲染时已经拿到了主接口的数据，或者根本没有使用接口返回，只是渲染；因此采取默认的连续渲染方式即可。
      - 但也提供了更精细的控制方式，主要有两个方面：
        - 对于无请求组件，直接默认就行。对于有请求组件，可以在请求的 finally 中调用下一级；对于以视频、图片为关键元素的组件，可以以视频、图片的 onload 或 onerror 来作为渲染完成的标志
        - 对于可能会请求超时、图片加载超时的情况，可以考虑通过 Promise.race 来控制一个超时，保证在一定时间内一定会触发下一级渲染，不会卡住
- **预加载**：接入预加载能力，主要是从美团 app 首页到会场页的预加载，和在会场页对商详页的预加载。
  - 预加载分为普通预加载（提前准备容器、编译解析代码）和深度预加载（提前执行代码）。深度预加载需要考虑接口请求的问题，成本较高，并且兼容不佳，因此只使用基础预加载能力
  - 在会场页对商详页预加载，主要要考虑到预加载带来的内存消耗和，因此不能同时对后续所有页面做预加载。根据页面用户流向发现从会场页进入商详页比例较高，进入其他页面较低，因此只预加载商详页。
  - 除了商详页，在有视频的时候还会预加载视频页
  - 执行时机：选择在tab吸顶之后预加载。因为根据用户流向数据，吸顶之后进入商详页的比例较高，因此在tab吸顶之后开始执行商详页容器的预热和页面预加载操作

实施优化的过程中，还需要对每个优化之后去做测试，尤其是高成本优化。
优化之后需要对优化前后的性能进行比较，查看优化效果。具体优化结果数据如下：

- 优化包体积：
  - 通过 cli 删除无用依赖、重复引入、较老的库：980KB -> 920KB
  - 引入 babel、单体下载组件库：920KB -> 860KB
- 会场页接入请求前置：
  - 首屏网络请求前置，提前的时间有限，测试结果：减少约 100ms
- 按需渲染：商详页优化部分内容，几乎没有改变
- 其他优化：解决各种问题。
- 代码分割：包体积本身没有变化；完全配置完成后，首屏时间减少约 400ms
- 分步渲染：不会直接影响首屏时间，但从录屏工具逐帧分析可以看到核心模块的加载速度变快。之前在骨架屏结束后仍有 200ms 的短暂白屏，优化后在 50ms 左右就出现了核心元素，后续内容在剩余 1000ms 内完全加载。
- 预加载：初步配置了会场页主动调用 api 预加载商详页和视频沉浸页，会场页暂未被预加载。因此会场页首屏加载时间未改动，但是商详页首屏加载时间在安卓上缩短了约 20%，在 ios 上缩短约 10%

最终测试结果：

- 会场页：
  - 安卓中端机：3500ms -> 2800ms
  - ios：2400ms -> 2000ms
  - C 指标：2 提升至 20，上线后不同机型都有 20%左右提升
  - 包体积：从 980KB 压缩包缩减到 800KB 以下
- 商详页：
  - 安卓中端机：800ms -> 400ms，主要是预加载的提升
  - ios: 500ms -> 300ms
  - C 指标：40 提升至 70，基本达到优秀标准

#### Control

Control：即对于优化完成的维持和复盘。

复盘：

- 还有一些优化手段没有使用：
  - 会场页的预加载、深度预加载：需要接入美团 app 首页，需要时间和价值评估
  - 会场页主接口数据缓存：考虑到主接口包含实时性较高的专区，缓存有可能导致刷新问题。后期考虑分离一部分接口，将变动不大的接口利用缓存进行优化

维持：

- 业务上，根据 RCF 预报定期检查性能问题变动
- 组内制定优化维护文档，当新增需求时要考虑到不会影响旧的优化手段
  - 比如预请求配置，如果主接口有变动，那么预请求也需要更新配置
  - 分包，如果有完全新加入的模块，在需求开发完后需要单独评审是否需要分割；分步渲染也是同理
  - 包体积：一些危险的包通过 cli 来限制安装，防止体积过大；cli 每次提交代码时通过 eslint 检查冗余代码存在（引用未使用），防止无用引入；每次发包之前都会检查是否有包过期、冗余安装等问题

## 项目难点

### 轮播组件

轮播组件的实现参考：https://github.com/meliorence/react-native-snap-carousel

在 rn 上轮播组件的设计可以通过 FlatList 来实现。FlatList 本身具有虚拟列表的优化，即使创建多个元素，也能有较好的性能。

轮播组件有几个关键的设计点

1. 无限循环：轮播组件的最常用的无限循环方式是这样：

假设一共有 N 个元素，那么列表的总宽度设置为 N+2 个元素的宽度。
例子如下，两端填充如图，当处于一端时，且即将进入循环状态的时候，如第二张图，从状态 1 滑动到状态 2，在滑动结束的时候，将当前的位置直接转到状态 3，直接 scrollTo 滚动到状态 3 的元素的位置。由于这个 scrollTo 是不带动画的，因此用户感觉不到滚动的发生。

![](https://pic.imgdb.cn/item/64b1131f1ddac507cc53a3a6.jpg)

我们可以将元素扩充，直接把两边的用于缓冲的元素加入到渲染的 data 中。如下代码就是库内的实现

```js
// loopClonesPerSide表示要在两边增加的额外元素数量
// loopClonesPerSide会影响在用户快速拖动时，看到的空白区域时间。如果过小，那么可能还没来得及瞬间跳转（scroll还没停止），这时会显示空白；如果数量合适，那么即使还没scroll停止，也能看到最新的元素

let previousItems = []; // previousItems是data从后向前裁剪，放在data前面
let nextItems = []; // nextItems则是从前向后，放在data后面

if (loopClonesPerSide > dataLength) {
  const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
  const remainder = loopClonesPerSide % dataLength;

  for (let i = 0; i < dataMultiplier; i++) {
    previousItems.push(...data);
    nextItems.push(...data);
  }

  previousItems.unshift(...data.slice(-remainder));
  nextItems.push(...data.slice(0, remainder));
} else {
  previousItems = data.slice(-loopClonesPerSide);
  nextItems = data.slice(0, loopClonesPerSide);
}

// 最后按照顺序合并。参考上面的实现原理就能理解
return previousItems.concat(data, nextItems);
```

2. 元素定位：即如何从 offset 对应到具体的元素，以及用户滚动得到偏移量后，如何定位到最近的元素。

方法就是设置一个数据结构 positions 数组，用于记录每个元素的 start 和 end

```js
// _getCustomData就是如上所述，为了实现loop扩充了data
this._getCustomData(props).forEach((itemData, index) => {
  // 这里的index是不真实的index，是复制过后的，但在布局中是基准
  // _index才是原本在data中的index
  const _index = this._getCustomIndex(index, props);
  let animatedValue;

  this._positions[index] = {
    start: index * sizeRef,
    end: index * sizeRef + sizeRef,
  };
  //...
});
```

在滚动得到本次的 offset 时，根据 offset 得出中心的位置，然后检查有哪个元素恰好在中心线的两边，那就选定是这个元素了

```js
_getActiveItem(offset) {
  const { activeSlideOffset, swipeThreshold } = this.props;
  const center = this._getCenter(offset); //
  const centerOffset = activeSlideOffset || swipeThreshold;
  // 这里是定位元素的关键
  // 如果没有centerOffset，那么确定当前是哪个元素的方法就是center >= start && center <= end，即center应该在元素的宽度范围内
  // 加上了centerOffset，其实是缩小了范围，相当于center >= start - centerOffset && center <= end + centerOffset，这样可能移动更小的距离就会到下一个元素去
  for (let i = 0; i < this._positions.length; i++) {
    const { start, end } = this._positions[i];
    if (center + centerOffset >= start && center - centerOffset <= end) {
      return i;
    }
  }
}
```

#### 轮播组件进阶

轮播图的基础实现比较简单，但是重点在于有一些进阶的话题，或者说是不仅限于轮播图，而是上升到抽象组件层面的一些东西。

1. 轮播组件要自己实现的原因，这个可以说因为业务需求，框架特殊性。但是自己实现了之后，需要注意什么地方？这里可以延伸出很多细节来

轮播组件的额外功能，以及为视频组件的嵌入做出的适应。
基础功能就是基本的自动播放、拖动播放、循环、定位这四个逻辑。

进阶功能：

- 轮播图个数的控制。之所以不采用内部的轮播组件，一个重要原因就是不支持对于多张图的显示。而现在组件中包含了这部分的逻辑。

具体是怎么来的呢？

组件需要被传入的 2 个计算属性是 sliderWidth 和 itemWidth，其中如果有 padding，itemWidth 也必须包含 padding 的值。
通过这两个值的比例，我们就可以得到可视区域内的元素数量。然后将 width 设置给具体的 list，就可以保证可视区域最多只会有`sliderWidth / itemWidth`个元素。
然后在`_getActiveItem (offset)`内部，调用`_getCenter`获取当前的中心位置，再遍历元素找到在中心位置附近的元素，将其设为 active 即可。无论显示多少个，始终只有一个 active。
这样我们只需要改变 sliderWidth 和 itemWidth 的比值，让他们能正常显示，就可以做到多张图片显示了。

- loopClonesPerSide 的实现。学习到的大部分轮播图在实现 loop 效果时，通常只会在两边超出时多增加一个元素。这样在多张轮播的情况下，如果用户拖拽到底，就会导致显示出空白。设置了这个 api，可以控制在两边额外渲染的元素数量，使得用户即使快速拖动也不会看到很多空白区域。

但是造成的问题是，所有的 index 都需要对照映射。由于 data 被扩充，因此在组件内获取的 index 并不是原来的 data 对应的 index，在`getDataIndex`方法中可以从 data 内的 index 获取到真实的 index。方法就是判断 index、loopClonesPerSide 和 data.length 的大小关系

```js
if (index >= dataLength + loopClonesPerSide) {
  // 如果在data的右半边额外数据部分，直接减去前面
  return index - dataLength - loopClonesPerSide;
} else if (index < loopClonesPerSide) {
  // 如果在前半部分
  if (loopClonesPerSide > dataLength) {
    // 按照loopClonesPerSide的值创建一个数组，从后向前遍历index找到真实的
  } else {
    return index + dataLength - loopClonesPerSide;
  }
} else {
  // 如果在中间，那直接减去前半部分就行
  return index - loopClonesPerSide;
}
```

- api 设计。这里就是重头戏了，除了组件能正常渲染所必须的 api 之外，还要提供一些能帮助实现后期视频功能的 props。

下面是不同的 api 设计内容，大致可以分为几类

1. 必需属性，包括 itemWidth、sliderWidth、data 和 renderItem。其中后两个主要是传递给 list 的。renderItem 进行了重写，可以传递 currIndex 和 items 给元素

2. 操作属性，这部分属于可以对轮播图内部设置一些值。包括但不仅限于

- activeSlideOffset，控制轮播图偏移多少会到下一个
- enableScroll，如果为 false 就不会响应 onScroll、onScrollBeginDrag、onTouch 等等事件
- useScrollView，因为了解到在一些安卓机型上，FlatList 会因为内部错误而导致不能正常渲染，因此可以采用兜底为 ScrollView 的方式。
- loop，循环，主要用在生成新索引、新元素，以及实现索引映射的时候
- loopClonesPerSide，上面说过
- autoplay 相关，还有 autoplayDelay 和 autoplayInterval

3. 样式属性，主要是一些针对 slider container 的样式，可以附加在 list 外层的 container 上。还有一部分样式是针对 item 组件的。

- 为了防止样式影响布局（比如影响 itemWidth 和 sliderWidth 的比例关系），样式做了严格的类型限制，只允许部分不会影响布局的属性，比如颜色、外边框等。在处理这两个参数时也只会取这些值。

4. 回调。回调主要是方便外部组件能获取内部的动态的值，主要包括

- onSnapToItem，当移动到一个元素时（完全移动后）触发
- onActiveItemScrollToNext：这是一个帮助控制视频组件的回调，在 onScroll 中传递当前的 offset、`offset / center + activeSlideOffset`，并且通过\_getActiveItem 得到当前 activeItem 和状态内的不同，就会触发这个 api 并返回 true。如果相同返回 false。通过这种设计可以让视频组件元素及时被清除。

5. ref。通过暴露 ref 的方法来让外部获取 ref，可以通过 ref 获取到 slider 实例，调用方法。比如把 stopAutoPlay、snapToNext 等方法暴露出去

- 但是要注意参数的准确性。最好的方法是永远*把暴露的方法和内部方法分开*，内部方法加一个`_`。这样在外部调用方法时可以检查参数，防止出现错误。

对于 props 的设计，其实有很大的讲究。说到这个就要提一些组件开发需要注意的点了。
如果这个组件未来可能会发布成库，或者被组内其他人去使用，那么应该更加完善哪些内容？

参考来源：https://www.51cto.com/article/747510.html

1. props 设计。主要要考虑：

- props 的名称，风格要统一，要按照不同类型提供。
- props 设置默认值，尽可能采取多的默认值。比如轮播组件除了必须的三个属性之外，其他的默认值都要设置好。默认值可以单独维护一个 defaultProps
- 维护好 props 的类型 IProps，可以通过 tsdoc 来为方法和属性注明含义和类型限制。
- props 的兜底处理，当 props 传入非法值时怎么处理：采取默认值，并进行 warn。
  - 如果是关键 props 传入有问题，比如类型出错、没传等情况，那么除了 error 之外，还不能进行渲染。非关键的可以 warn，然后取默认值

2. 其他方面，可能和这个项目关系不大，比如

- 增加更多的`slot`。对 react 来说，其实就是直接渲染传递`ReactNode`。renderItem 其实本质也是这种方法
- 独立性，这算是老生常谈的话题。让用户只感知到 props 以及 callback 回调的数据，内部封装不暴露。其实也是一种开闭原则，对扩展开放，对修改封闭。
- 扩展性，比如某些时候某个 props 的值是 boolean，但是如果情况多了的话，两个值就可能不够用。这时再扩展为枚举类型，以支持更多的属性。
- 纯粹，一个组件只实现一种效果。比如 Input 组件，可能还可以扩充为其他用途的组件。
- 样式和类名：主要是类名的统一、规范和样式的统一。这个话题展开就非常大了。在 antd 等组件库中采用的是 scss + css module 的形式，再加上 classNames 库，可以实现把 props 对应的样式设置不同的类名，实现不同的样式。
  比如这样： ![](https://pic.imgdb.cn/item/64bff9a31ddac507ccac1706.jpg)
- 基本的优化：组件内部要避免无意义的渲染，同时如果像轮播图这种内部还引入其他组件的，也需要注意传给内部组件的 props 使用 useMemo。具体有这几方面：
  - 尽可能不用 state，大量变量可以用 ref，如果不影响更新就不用 state
  - useMemo、useCallback，尤其是对于 style、className 等变量
  - memo 或 shouldComponentUpdate 优化。可以在 memo 中根据 props 类型编写专门的比较函数。

### 轮播+视频

实现的关键点有：

1. 视频的单例。出于移动端性能和视频组件的考虑，页面上如果同时拥有多个视频组件挂载，即使没有视频源或者出于停止播放状态，也会导致页面内存占用过大，出现卡死闪退等情况。

因此需要在页面保持视频组件只有一个，同时还要实现轮播播放视频效果。

考虑的实现方式有两个：

- 将视频组件放置在轮播图中心，通过 z-index 控制显隐。轮播图滚动时，控制视频组件更换源，加载完成后显示。主要是放置重复销毁创建的消耗

这种方法简单，但是问题在于观感很差。当轮播图快速滚动时，视频组件就会出现反复显隐的情况，表现为和轮播组件闪烁；

- 将视频组件放置在轮播图内部，和商卡同级，通过 active 控制挂载。

即在轮播组件中维护一个 activeIndex 的 state，在 renderItem 中比较 activeIndex 和参数 index。card 组件暴露一个控制挂载/卸载 video 元素的方法，当 activeIndex === index 时执行挂载。

当 onScroll 事件发生时，暂停视频元素的播放

当 onActiveItemScrollToNext 调用并返回 true 时，修改轮播组件内的 state，然后 renderItem 会执行，清除所有的视频组件挂载，并显示商卡。这个过程是切换的前一个瞬间，在这里完成组件的卸载和商卡显示主要是为了提升观感，让切换过程提前执行，否则有时候商卡已经到了两边，视频还在显示。

当 onSnapToItem 触发并返回 currIndex 时，再次修改 activeIndex，然后 renderItem 方法根据 index 挂载对应的视频组件。

如果没有切换到下一个，那么就只是暂停视频，当松手时继续播放。

2. 当页面离开会场页时，销毁视频组件。通过会场页面的回调检测到用户离开

这里其实要说的话，应该要结合轮播图来说。比如，轮播图增加了哪些功能能更好支持视频，否则自行实现轮播而不是采用组件就有些没有意义了。

### RCF 优化

优化主要从这几方面来说

1. 优化原因：性能评分偏低
2. 优化指标

- RCF 指标的含义
- RCF 指标的测量方式和标准
- 优化期间的检测方式
- 优化完成之后的验证方式

3. 优化方式

- 具体优化方式
- 为什么采取这样的优化方式，为什么不采取其他的方式
- 优化接入，关键点，实际操作方法
- 优化效果，如何体现
- 业内通用的其他优化方式如何

4. 专项优化

- 怎么发现的问题（比如闪烁、卡顿等）
- 发现问题工具
- 解决问题
- 验证问题解决
- 工具的适用性，能不能每次开发完后都检查性能

5. 其他

- 优化验证的方式，在不同机型上和模拟器上，打 release 包在应用中运行测试

#### 优化原因

1. 线上 RCF 指标偏低。公司内有针对 c 端页面的 RCF 指标监测，分析发现我们的多个页面评分都偏低，优化重点为评分最低的几个页面，主要为会场页和商详页。

根据两个页面的结构分析指标偏低的原因，主要原因为：

- 会场页
  - 引入轮播图和视频组件，包体较大，没有做好分包导致首屏加载时间过长
  - 轮播图、视频组件的渲染时间较长，没有做渲染分级，导致整体页面渲染时间变长
- 商详页
  - 模块较多，但首屏模块只有一个，其他模块都在首屏时渲染，拖慢页面整体渲染速度
  - tab 里不同页面都做了加载，但是根据埋点情况发现其他 tab 页访问不多，没必要在首屏包中加载，可以做按需加载

2. 测试时发现一些问题，比如闪烁、加载缓慢

- 会场页
  - redux 传递列表滚动偏移数据导致轮播组件频繁刷新，出现闪烁。通过 wdyr 确定问题出现的组件和原因
  - 吸顶时显示券列表出现卡顿，点击 tab 吸顶时会感到明显卡顿。通过 RN debugger 和 Profiler 等工具定位到是由于券列表采用 ScrollView，当券数量大时会出现卡顿

#### 优化指标

主要指标为

1. RCF 指标，即线上性能指标，是优化的主要方向。

- R：响应时间，主要是从用户触摸事件开始到页面做出第一帧变动的时间，主要依赖 native 测算。大致原理是“追随”点击事件的流转，直到点击事件被 JS 消费并且点击事件修改的布局在 UI 线程完成更新的时间。
- C：首屏加载时间。统计方式是从页面启动、native 代码加载开始，一直到 js 完成渲染、元素稳定为止。测算方式可以参考 rn 优化八股中对 LCP 值的测算，即页面的不同元素渲染时间的依次统计，
- F：实时帧率，主要是页面帧率，会考察最大连续丢帧的情况

2. 其他调试指标，即优化期间的一些判定指标，主要通过调试工具体现

- 首屏加载时间测量，比如从 3000ms 优化到 1000ms 左右
- 包体积测量，可以检测到通过网络请求下载的包体积，用于检查包体积优化和分包情况
- 重复渲染，检查渲染次数和函数执行次数，定位重复渲染原因
- 页面帧率，是否出现掉帧情况

3. 调试工具指标，比如 wdyr 的输出、profiler 的合理渲染图等等

#### 优化方式

针对会场页和商详页做不同的优化

##### 会场页

会场页优化：C 指标得分只有 3 分，线上平均加载时间达到 3000ms，通过调试工具发现会场页包体积的主包体积达到 3MB 左右

1. 通过 RAMBundles + InlineRequire 进行分包，将庞大模块分离出去减小包体积。

分包的对象主要是大量的组件。这些组件虽然有些不参与首屏渲染，但仍然包含在首屏加载的包体积中。包括

- 大量的 Modal 弹窗。有些弹窗内还有很多其他的功能组件，在首屏都是不需要的，可以在弹窗应该显示时再加载
- 轮播图和视频组件。虽然这两个在首屏，但是仍然占据了很大的包体积。考虑将其延迟加载，当页面的列表元素完成渲染后，再加载这两个元素。在此之前采用同位置的商卡组件做占位

内联导入的代码其实比较简单，简单来说就是

```js
let SomeComponent = null;
const App = () => {
  const [isRender, setRender] = useState(false);
  const didRender = () => {
    SomeComponent = require("/path/to/component");
    setRender(true);
  };
  return (
    <>
      ...
      {isRender && <SomeComponent />}
    </>
  );
};
```

由于 require 本身是同步的，因此可以看做就是在控制元素的条件渲染。
内联引入需要和 RAM 配合，后者通常是需要开启打包时的选项。
RAM 本质上是开启了特殊的打包方式，让 js 以模块为单位单个打包，可以以模块为单位获取。同时配合 metro 等打包工具实现的 Indexed RAM Bundle 形式，可以保证细粒度的同时，文件数量本身并不会增多，从而导致请求和加载负荷增加。

---

另外，在分包方面还要根据模块的实际应用场景来做具体的懒加载。比如：

- 数据驱动加载，在少数情况下才会出现的模块，等到有相关数据时再加载对应模块 UI 代码，如弹窗和活动浮标；可以在首页请求接口之后判断是否有需要首屏展示的弹窗的数据，如果有再去主动加载 modal 的代码。对于其他需要手动触发的，则到手动触发时再加载。
- ⽤户⼿动触发⾏为后再加载，如筛选弹窗、Tab 切换。
- 不需要⽤户触发就会加载的模块，根据模块的重要程度，按优先级进⾏分步加载和渲染，保证⾸屏元素优先渲染出来，能加快核⼼内容展示，提⾼⽤户体验；
- ⾸屏模块渲染完成后，再主动加载⾮⾸屏模块。酒店前置⻚⾮⾸屏模块如榜单、猜你喜欢模块，酒店详情⻚⾮⾸屏模块如评价、附近热销模块。

优化效果：分包之前主包体积达到 3MB，会场页主要进行三个分包，主包体积降低到 1.5MB

2. 优化包体积，删除无用库，剔除 lodash 改用内部的库（仅引入单个方法，如 debounce 等），进行 tree-shaking 优化

- 首先是清除一些库。从 package.json 出发，找到哪些库是没必要引入的。比如 lodash 只使用了几个方法，那就应该考虑从其他更小的内部库中导入。这些优化过的库支持按需加载，同时对 tree-shaking 的支持更好。还有一些组件库和类似 KNB 这样的库取消全量引入，而是只引入他们的单个形式。
- 通过 webpack 插件的形式，将导入优化为具体的文件路径，避免全量引入。
  比如：

```js
import { Button } from "xxx-desgin";

优化后;

import { Button } from "xxx/desgin/lib/button";
```

> 注意：替换导入路径、删除包等操作都是有风险的，要注意渐进式的替换，同时做好自测和 QA

- 其他，比如 icon 库不要本地导入等

优化效果：主包和其他分包的体积都减小，总体降低到 900KB 左右

3. 分批渲染。

分批渲染在 web 上其实是不太有意义的。这里的分批，其实应该理解为“延迟”或者“异步”。主要为了解决的问题是，如果同时渲染很多部分，那些不太重要的部分有可能会发起网络请求而占用核心部分的接口返回，比如在 web 端会限制页面最大连接并发数。

在 rn 中分布渲染的意义在于：连接 js 和 native 的 bridge 层是异步通信的，并且依赖于队列这样的数据结构。如果同时发起大量模块的渲染，那么核心模块有可能会被放在消息队列较后的位置，从而导致不能及时渲染。
另一方面，有些模块可能会包含一些导致通信或计算耗时较大的代码，比如 js 驱动的动画、大量层级的 react 组件等。这些模块可能会带来较大的压力，在低端机上可能会导致加载缓慢，从而影响其他模块的加载。

> 引用：
> MRN 通过前端脚本映射原⽣组件的技术⽅案，渲染路径总结起来是：渲染前端 Virtual DOM -> 映射为 Native 指令 -> 将指令传输到 Native 侧 -> Native 执⾏指令完成渲染，前三个步骤中，较重的业务逻辑或不合理的代码通常会带来较⻓的计算和通信耗时，在低端机器上尤为明显。我们通过分步渲染能有效解决这⼀问题，其核⼼思路主要⽤于⻓内容⻚⾯，如列表⻚、详情⻚等。随着业务迭代，⼀个复杂的⻚⾯多则数⼗个模块，如果进⼊⻚⾯时同时渲染所有模块，那么就会拖慢核⼼模块的渲染速度。

优先渲染轮播图、列表组件，对 nav、浮窗等其他元素降低渲染优先级。同时抽象出优先级渲染控制组件 Priority，便于在其他地方也进行分批渲染控制

Priority 的实现可以参考另一篇博客。
主要应用在，将列表、轮播图组件赋予最高优先级，而降低其他组件优先级。

另一方面，不同模块的渲染完成时间也不能仅通过 useEffect 来得到，比如图片、视频等含有静态资源的组件，可以以 load 事件为标准。
还有关于首屏组件的界定，其实核心不是在于哪些组件是首屏，而是哪些组件是“核心”。核心模块应该有着更高优先级，即使没有数据或展示占位；核心模块的界定则由自己确定。

4. 重复渲染优化。通过 wydr 和 debugger 定位到轮播组件发生大量频繁渲染，原因是 redux 的状态，发现列表移动时更新了 redux 全局状态导致组件无用更新。

定位问题时发现页面闪烁。通过 Debugger 发现页面滚动时轮播组件大量重复渲染。
然后通过 wdyr 对轮播组件进行检查，发现更新原因是 redux 的 useSelector。
滚动事件触发 redux 的全局属性里的某个值更新，引起全部持有该状态的组件更新

解决方法是采用全局事件代替 redux 进行单纯的数据传递和状态共享，通过 Animated 组件代替之前通过修改 state 达到的动画效果。

5. 卡顿优化。由于吸顶时渲染券列表，券列表采用 ScrollView，当券数量多时会感到卡顿。

首先是从吸顶行为的周围排查，检查吸顶操作进行时有哪些组件发生状态变化。
然后通过 Profiler 工具检查到吸顶操作时，有一个 ScrollView 组件渲染耗时很长，定位发现是券列表组件
将其改为 FlatList；兜底方案：只显示少量券，当券数量多时不在首屏渲染，而是单开一个券列表浮层，首屏最多渲染三个。

6. 网络优化。主要是接入了 mrn 提供的请求前置，在启动期间就预请求会场所需数据，但效果不明显。

7. 其他优化。比如视频组件的离屏销毁等

总体优化结果：

- 包体积从 3MB 降低到 1.5MB，首次加载的包体积仅有 900KB
- 首屏加载速度从 3000ms 提升到 1000ms 左右，C 指标从 3 提升到 30
- 闪烁现象解决，卡顿现象解决

##### 商详页

1. 分批渲染。商详页模块较多，从上到下有商品详情、购买须知、猜你喜欢、评价等多个模块。首屏应该只展示详情模块，其他模块可以采用分批渲染的形式降低渲染优先级。

更进一步，猜你喜欢模块可以进行懒加载，当滚动到底部时才会渲染猜喜列表。保证不会影响主要模块的渲染速度。

2. 预加载和预请求。商详页属于二级页，因此预加载可以做很多内容。通过业务埋点，可以得出用户通常从会场跳转到商详页的比例较高，大约有 30%-40%，而专区、搜索页等的跳转比例较低。

因此可以在会场页渲染完成时，预加载商详页。执行由 mrn 提供的方法，预热商详页组件。

3. 头图优化。在跳链中加入头图的 url，商详页可以快速取到对应的头图并进行加载。不同分辨率的区别仅是后缀不同

优化效果：商详页 C 指标提升 20%左右，加载时间从 600ms 降低到 400ms，同时由于预加载的引入，秒开率得到提升。

### 关于骨架屏和初次渲染的关系

首先明确一点：骨架屏的消失应该是在数据有返回的时候。比如项目有一个主接口，当主接口返回时，骨架屏消失，然后这时才挂载具体的内容。

这个时候，作为具体内容的组件实际上是在这样的情况下开始渲染的：

- 主接口已经返回数据，此时传入的 props 是有具体值的
- 只会初始化渲染而非 rerender，因此 props 不会改变

参考下面的代码示例：

```tsx
function App() {
  const appData = useAppData();
  const showLoading = useMemo(() => !!appData, [appData]);
  return (
    <>
      {showLoading ? (
        <CoreComponents data={appData} />
      ) : (
        <div>
          <h1>我是骨架屏</h1>
        </div>
      )}
    </>
  );
}

export default App;
```

可以看到初始化是渲染骨架屏，而 CoreComponents 并没有渲染。当 appData 返回非空值时，才让骨架屏消失，然后开始渲染 CoreComponents 和他内部的子组件。

因此对于实际的业务组件，即 CoreComponents 和内部组件来说，第一次渲染就是携带有具体的 appData 作为 data 的，不存在“先展示空值再请求填充”的情况。

既然是初次渲染，那么分步渲染也就能生效了。
同时也可以解释项目首屏加载发生的过程：

- 骨架屏是预渲染的，因此一进入就会展示
- 骨架屏显示期间，实际上是包解析执行+主接口请求的时间，这时虽然不包含业务组件的渲染，但业务组件之外，比如 App 组件实际上也 render 了的。
- 主接口请求返回，骨架屏消失，业务组件开始渲染。这个过程会有短暂白屏，因为业务组件渲染需要时间；这也是对业务组件渲染的优化体现的地方，即通过分布渲染、懒加载等方式，尽快完成这里的渲染
- 业务组件带数据渲染完毕，显示完整的页面。从这里才开始计算 FMP、FSP、LCP 等指标，最终当首屏元素稳定时，作为 C 指标的结束值。

# 项目提问题

## 难点和亮点

难点：

1. 轮播图的开发。主要有：

- 对轮播图的实现原理不熟悉，包括滚动定位、无限循环等
- 在轮播图需要引入视频，但是视频组件又不能在页面挂载过多，需要考虑视频如何接入轮播图

2. 性能优化，主要有：

- 优化首屏加载，需要系统思考有哪些问题，然后如何针对性优化，还需要知道哪些优化是可以做的
- 定位性能问题，需要找到性能问题的发生原因以及具体位置

3. 地图，主要有：

- konva 事件系统的探索，要实现事件委托，但事件系统不了解。通过查阅文档、搜索资料、查看 issues、阅读源码，最终了解了事件流
- 优化 canvas 性能，需要知道有哪些优化手段，以及有哪些内容是 konva 已经做得，哪些是需要我们做的

亮点：

1. 特团项目

- 轮播图提供了对视频组件接入的支持，以及轮播视频的单例控制、及时销毁
- 优化

2. 超管项目

- 采用 recoil
- 利用 konva 实现一些优化手段，比如可视区域加载等

## 特价团购

### 轮播图

#### 1. 为什么要自行开发轮播图？

- 在公司内部采用的框架内，不能直接引入 rn 或 web 库，会有使用和兼容上的问题。
- 公司内部的组件库提供的轮播组件不符合要求
- 由于要接入视频，希望对轮播组件做更精细的控制，同时也更方便定位问题

#### 2. 你说“并对轮播加入视频的功能提供了支持”，具体说说有哪些支持？

- 首先是提供了基本的轮播功能，包括无限循环、手动拖动、自动播放等
- 在实现细节上，主要向外部提供了一些方法，在轮播图状态改变时能够在外部获取到，从而支持视频的变化
  - onActiveItemChange：当滚动事件发生时，当前轮播图滚出限定范围，如果用户松手或者滚动继续，那么就会移动到下一张图。当这个事件触发时，在外部就可以通过控制状态让每个 item 上的 video 销毁。
    这个方法提供了当前正在滚动的元素的索引和下一个即将滚动到的
  - onSnapToItem：当用户松手或滚动事件完成，正式滚动到某个轮播图时，触发这个时间，这时可以再修改状态去挂载新的视频组件
  - 视频错误兜底：只有当视频组件播放事件触发时（类似 onCanPlay），才会通过修改 z-index 显示视频并开始播放，否则就只显示商卡
- 其他：还有可以做的：在视频加载到下一个之前，提前预加载视频和封面图

#### 3. 轮播图是怎么实现的？实现过程中有哪些难点，踩过哪些坑？

分这几个方面去说：

- 基本容器：FlatList 和 ScrollView 的选择
- 基本功能：
  - 切换功能：
    - 首先需要确定每个元素的尺寸和整体可视区域的尺寸，以及 positions 数组确定位置
    - 自动切换：根据 index 获取指定轮播图的中心位置的 offset，再使用 scrollToOffset 滚动到该 offset 即可
    - 手动滚动切换：
      - onScrollBeginDrag：记录开始移动时的 offset 和 activeItem，暂停自动播放
      - onScroll：实时计算 activeItem 并更新全局的 activeItem，如果发生切换，即当前的 activeItem 不等于开始时记录的，就触发回调
      - onScrollEndDrag：根据 activeItem 滚动到指定的 activeItem 上，触发回调，回复自动播放
  - 循环滚动实现：
    - loopClonePerSide 防止快速滚动时看到空白。前后都加
    - 根据索引关系确定真实索引和加入之后的索引
    - 当滚动到真实索引范围外，计算真实索引，无动画滚动回去对应的位置
  - 自动播放

难点和坑：

- 难点主要有：
  - 轮播图这些功能原理，以及在特定框架下实现，对 rn 不是很熟悉的情况下实现。
    - 解决：看一些相关原理性文章，参考其他轮播组件库的源码的设计方式
- 踩坑：
  - FlatList 的兼容问题：在一些机型上出现了不能显示图片，滚动之后才能显示的问题。增加了 ScrollView 兜底
  - 封装组件：对外提供 props 和方法时，没有把内部方法和外部方法区分开，导致传值出现问题，轮播图的 bug

#### 4. 轮播图怎么做优化的？

- 利用 FlatList 的优化：
  - 设置合适的初始化渲染数量，3+2 或者 3+loopClonePerSide
  - 设置合适的 windowSize，2 \* initialNumToRender + 1，参考官方文档的建议设置
  - getItemLayout
- 设置 React.memo，在外部使用时用好 useCallback、useMemo 等
- 尽可能不设置 state，大部分数据使用 useRef 和 useMemo 保存

#### 5. 轮播图视频是怎么嵌入的，“后期通过优化手段保证页面性能稳定”具体对轮播图方面做了哪些优化？

- 利用提供的 api，及时销毁 video 元素
- 当轮播图离开可视区域时，暂停视频播放。
- 每个子元素使用 memo，严格控制 props，使得每次 activeItem 改变时，总共只有两个子元素状态改变
- 降低商卡组件复杂度，把背景、渐变或者其他实现起来嵌套较多较复杂的元素替换成图片，然后采用纯色兜底

### RCF 优化

#### 1. 讲一讲都做了什么优化

1. 背景

- 问题来源：
  - C 指标偏低，会场页加载时间约为 3000ms，商详页为 1500ms
  - 测试过程发现卡顿、闪烁，需要找到原因并修复
- 性能指标：
  - R：响应时间，主要是从用户触摸事件开始到页面做出第一帧变动的时间，主要依赖 native 测算。大致原理是“追随”点击事件的流转，直到点击事件被 JS 消费并且点击事件修改的布局在 UI 线程完成更新的时间。
  - C：首屏加载时间。统计方式是从页面启动、native 代码加载开始，一直到 js 完成渲染、元素稳定为止。（C 指标的测量方式？）
  - F：实时帧率，主要是页面帧率，会考察最大连续丢帧的情况
  - 线下指标：录屏工具测算 FCP、FMP、TTI 以及跳变次数。线下测试机型有限，不一定能覆盖全部情况

2. 目标：会场页加载耗时减少一半以上，商详页降低至 1000ms 以下，解决测试发现的性能问题

3. 行动：

优化的核心思想和系统性的方法：按照页面加载链路来进行专项优化。

**native 启动、资源加载、代码执行、数据获取、绘制渲染**

每一个优化链路内部的优化，采用**前置、简化、拆分**的角度来考虑
还要考虑哪些是前端可以做的，哪些是需要接入客户端的

1. native 启动：

- 接入：进入会场页完成加载之后，就预加载商详页容器以及下载商详页的包，但没有解析执行，也没有预请求

2. 资源加载：

- 包体积优化
  - 包体积缩减
    - 背景：不支持 tree-shaking，需要自行优化
    - 修改 debounce、deepClone 方法的引入，自行实现或引入内容部库
    - 优化全量引入的组件库的引入路径，通过 babel-plugin-transform-imports 来自动修改路径
    - eslint 和 husky 设置未使用的代码和文件及时删除，否则不能提交，保证实现
  - 代码分割
    - 分割非首屏、数据驱动、手动触发和切换
    - 分割方式
    - 首屏的预加载
  - 接入：业务包和资源包分离

3. 代码执行和数据获取

- 网络请求
  - 合并请求
  - 预请求，在进入二级页的同时开启请求，相当于请求前置
  - 跳链优化，跳链包含部分商品信息
  - 部分手动缓存，比如会场跳沉浸

5. 绘制渲染

- 渲染优化
  - 优先级分步渲染
  - 延迟渲染
  - 降低代码层级，优化复杂嵌套

优化结果：首屏加载时间从 3000ms 降低到 2000ms 左右（有待商榷），c 指标提升到 30 分性能问题得到解决
商详页降低到 600ms 左右

## 超管平台

主要要注意一下 canvas 优化的部分和 recoil 选型的部分

为什么用 recoil

- 原子化
- 状态离散
- 方便简单
- ts 支持好
- 符合 react 数据流

技术选型的标准

- 功能是否够用
- 兼容如何，浏览器兼容、react 兼容、其他库兼容等
- 是否足够好用，上手难度如何，容易出现问题吗（搜索相关资料以及 issues）
- 是否频繁更新，维护
- 项目中使用，做好完备测试

canvas 优化：
实际做的：

- 可视区域绘制
- 缩小到一定程度不绘制文本
- 利用 cache 接入离屏渲染
- 采用列表优化方式，对每个元素用 memo 包裹，防止重复渲染

其他更多实现：

- 瓦片地图
- 脏矩形渲染
- 分块加载
