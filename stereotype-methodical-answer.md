面试官好，我叫赵梓轩，来自电子科技大学，我的专业是软件工程，目前是大三。

我学习前端大概有一年半左右的时间了。我第一次接触前端是通过学校工作室学长的带领，感觉到自己对前端比较感兴趣，并且后续在和其他同学参与项目的过程中都是前端开发的角色，因此选择从事前端这个方向。

我在字节跳动实习过三个月左右的时间，实习期间主要负责机器人超管平台前端的开发工作，和后端、产品、测试等同学配合完成了多个任务排期，使得超管平台项目功能更加完善和丰富。在项目开发过程中我参与了部分技术选型，针对项目中的问题采取了一些解决方案；

之后我也在美团实习过两个月的时间，实习期间主要负责特价团购营销会场页的开发，主要工作是完成美团app c端的页面功能增加，以及一些营销活动的需求。除此之外我还参与了以会场页为主的页面性能优化，通过多种优化方式提升了页面性能，通过问题定位工具找到页面性能问题点并解决，最终使得项目性能评分提高。

<!-- 比如针对项目中需要绘制地图的需求，我选择了 konva 来实现，因为 konva 为 canvas 提供了完备的事件系统，帮助解决了需要 canvas 交互的问题。在开发实现地图组件功能的过程中，我遇到了一些问题，也通过各种方式顺利解决了。

比如针对项目中的状态管理问题，我详细了解了 redux，并调研了 recoil、mobx、zustand、jotai 等其他状态管理解决方案，最后综合项目的实际应用情况选择了 recoil。 -->

贵公司在前端领域有着不小的名气，我对贵公司也十分向往，也很感谢贵公司能给我这次面试机会。

# HTML

- link 标签的作用和常见属性
  - 概括：链接外部资源
  - href：路径
  - rel：类型
    - stylesheet：样式
    - icon
    - 各种 pre（见下）
  - media：媒体查询
- **link 标签的各种预请求**
  - preload & prefetch
    - 二者作用和特点
      - preload
        - 不阻塞
        - 优先级高
        - 本页面使用
        - 各种资源，包括 js 和 css 内的资源，不仅限于 html 内
      - prefetch
        - 低优先级
        - 强制缓存
        - 下个页面使用
  - dns-prefetch
    - 预加载可能的 dns 解析
    - 和 pre-connect 一起用
  - pre-connect
    - 和目标建立连接，包括 http、tcp、TLS
- meta 标签的作用和常见属性
  - 概括：文档元数据，帮助浏览器解析
  - 添加关键字、描述等帮助 seo 的字段
  - http-equiv：作为本次 html 的响应头，csp
- **viewport**
  - 基本概念
    - 移动端的窗口
    - 响应式布局的基础
    - meta 标签控制
  - 三种 viewport
    - 布局视口：浏览器默认视口，布局的基础 document.documentElement.clientWidth
    - 视觉视口：可视区域大小 window.innerWidth
    - 理想视口：屏幕尺寸 window.screen.width
    - 响应式基础：布局视口 = 理想视口
- script 标签的 async 和 defer 属性效果和作用
  - async：异步下载同步执行，多个 script 不保证顺序
  - defer：异步下载异步执行，多个 script 执行顺序不变
  - module：类似 defer，异步加载依赖，异步执行
  - module async：类似 async，异步加载依赖，同步执行
- html 语义化的含义和意义
  - 含义：有名字的元素
  - 意义：
    - 对开发者：可读性
    - 对机器：seo、爬虫、读屏
- seo 优化
  - title、description、keywords
  - 语义化
  - 重要内容 HTML 代码放在最前
  - ssr
  - 非装饰性图片必须加 alt
- 页面通信的方式：https://juejin.cn/post/6844903811232825357
  - localstorage
  - shared worker
  - window.postMessage:跨域
  - service worker

# CSS

- 什么是 css 的层叠和继承，哪些属性可以继承，哪些不能？
  - 层叠：后覆盖前、高优先覆盖低优先
  - 继承：部分属性可以继承其父元素的属性
    - 可继承：font、text、color、visiblity
    - 不可继承：display、position
    - 控制继承：inherit、initial、unset
- **css 选择器有哪些，优先级是怎么样的，性能如何，选择器匹配顺序**
  - 概述：id > class = 伪类 = 属性 > 元素 = 伪元素 = 联合
    - 行内 > 内部 > 外部 > 浏览器用户自定义 > 浏览器默认
  - 优先级机制
    - 如上
    - 跨级不可超越
    - 越叠加越高
  - 效率
    - 概述：具体效率排名
    - 主要依据：最后一个选择器
    - 原理：浏览器对不同选择器查询方式不同。不是固定的，还取决于文档结构层级等因素
      - id 选择器：全局唯一，window 对象直接保存，最快
      - class、属性选择器：只需要遍历元素属性，也很快
      - 元素选择器：因为数量大，可能很慢
      - 联合选择器：同理，需要匹配多级，很慢
  - 匹配顺序：倒序
    - 原因：减少匹配次数
- 伪类和伪元素有什么区别，常见的有哪些
  - 概念
  - 举例：
    - 伪类：
      - 爱恨原则
      - （-child 和-of-type 的区别）
    - 伪元素：after/before
- css 的单位都有哪些
  - 举例
    - 大小单位
      - 绝对单位 px pt
        - **逻辑像素和物理像素**
          - 概念：
            - 逻辑像素和物理像素是什么
            - 两者性质（特点）
          - 逻辑像素和物理像素的对应关系（放大缩小）
          - dpr 是什么
      - 相对单位
        - em：用于字体/用于元素
        - 百分比：用于字体/用于元素
        - auto
    - 颜色单位：rgb rgba hsl hsla
- 常见的块级元素、行内块、行内元素都有哪些，什么特点？
  - 概括：
    - 块级元素有哪些
    - 行内元素有哪些
    - 行内块有哪些
  - 特点：
    - 块：宽度最大，单独一行
    - 行内：收缩宽度，纵向 padding 无效，合并一行
- 盒模型是什么
  - 概括：概念
  - 包含内容：content、padding……
  - 类型
    - 分类依据
    - 两种类型
- 外边距折叠是什么情况，怎么处理
  - 概括
  - 三种情况，每种的：
    - 出现情况
    - 解决方式
- **BFC 是什么**，有什么用，怎么触发
  - FC 是什么
    - 概念：一个模型，将元素转化为一个个盒子，盒子内和盒子间的布局
    - 分类：BFC IFC FFC GFC
  - BFC 是什么
    - 概念：块级盒子的布局形式
    - 组成：
      - 每个块级盒子都会参与构建
      - 部分块级盒子会直接生成
    - 触发
      - overflow 除 visible
      - 浮动和绝对定位
      - flex 和 grid
    - 性质
      - 不被覆盖、不被抽空、内部外边距折叠
  - IFC 是什么
    - 概念：行内盒子的布局形式，更多的是行内盒子之间的
    - 相对于 BFC 的特点：一个盒子（line-box）包裹行内元素
    - 创建方式
    - 性质
      - IFC 内部的布局规则
      - line-height
      - padding 和 margin 仅水平
      - vertical-align 和 text-align
  - 其他 FC
    - FFC：类似 BFC，但部分属性无效
    - GFC：外部表现类似 BFC，内部分格
- 浮动是什么，有什么用，怎么清除
  - 概念
  - 浮动后元素的性质
    - 自己的性质
    - 和其他正常元素的关系
  - 用处
  - 清除浮动
    - 目的：防止浮动元素的影响
    - 方式
- position/display 有哪些属性，有什么特点
- z-index 顺序：
  - 背景 负 z-index 块 浮动 行内 z-index0 正 z-index
- 隐藏元素的方法有哪些，各自什么特点
  - 列举：
    - display
    - visibility
    - opcity
    - z-index
    - transform scale
  - 每个特点
    - 是否可监听绑定事件
    - 是否继承
    - 是否占据原位置
- 怎么创建一个响应式图片
  - 基本 css 创建：max-width: 100%;height: auto;
  - html 创建：
    - srcset
      - 属性含义：图片+单位
        - 单位：w 和 x
    - size
      - 属性值：媒体查询
      - 和 srcset 配合
    - picture 和 source
      - 两者的性质，功能，类似于 video、audio
      - 配置方式 source 上的 media
- **flex 怎么用，有哪些属性**
  - 基本概念
    - 弹性盒子
    - 主轴和交叉轴
  - 基本属性
    - 容器属性：wrap direction justify align
    - 元素属性 grow shrink basis
      - 基本含义
      - grow 的取值及其效果，几种情况
        - 元素全不定宽：按比例
        - 有元素定宽：划分空白
          - 定宽元素设置：额外增大
          - 不定宽元素设置：空白划分
        - 行内元素：生效
      - basis：
        - 含义
        - 优先级高
        - 0 和 auto
- grid
  - 基本概念
    - 行和列的划分
  - 使用
    - 划分行和列
    - 设定元素的起始和结尾行列位置
    - 设定元素在内部的位置
- 怎么判断元素是否进入可视区域？判断依据的属性都是什么意思？
  - 方法：
    - el.offsetTop - document.documentElement.scrollTop <= viewPortHeight
    - getBoundingClientRect
- css 怎么画一个三角形
  - border
- 垂直居中、水平居中、垂直水平居中，如果不知道父元素宽高的话怎么做？如果不知道子元素宽高怎么做？都不知道怎么做？
  - 水平居中：
    - flex 和 grid
    - margin -- 子元素宽度
    - text-align -- 行内块
    - position + transform
  - 垂直居中：
    - flex 和 grid
    - position + transform
    - position + margin auto
    - line-height + vertical-align
- 两栏布局怎么实现
  - flex
  - grid
  - float + margin-left
  - 绝对定位 + margin-left
- 三栏布局怎么实现
- 实现一个高度始终为宽度一半的矩形
  - aspect-ratio
  - padding-bottom
- 什么是**响应式布局**，怎么实现？
  - 概念：一套布局，动态变化
  - 不同方面
    - css 布局属性
      - rem 布局
      - flex 和 grid
    - css 元素属性
      - 百分比、vwvh 等单位设置宽高
      - 响应式图片
    - 媒体查询
      - 确定断点（bootstrap）
      - 移动优先/pc 优先
    - viewport
      - 保持 viewport 标签的设置，关键是 width，这个 width 决定了 vw、媒体查询、百分比等单位的基础大小。
- css 变量
  - :root 设置，`var()`使用，可用在 calc 中，元素内可覆盖
  - 相对于 less，更方便在 js 中处理
- 暗黑模式

# JS

- 数据类型有哪些，分为几种
- 引用数据类型和基本数据类型有什么区别？
  - 分别有哪些类型
  - 存储位置：栈（大小确定）和堆（大小不固定，更灵活）
  - 引用方式：直接和索引
  - 修改情况
- `==`的转换规则
  - 原始数据之间
    - 类型相同直接比
    - null 和 undefined 相等，和其他的都不转化
    - 其他跨类型：
      - boolean 和任意其他原始类型：boolean->number
      - number 和 string：string->number
  - 对象转化为原始
    - `Symbol[toPrimitive]`函数的返回值
    - valueOf 和 toString，取决于要转换的类型
  - 对象之间
    - 比较索引
- **检测数据类型的方法**，检测数组有几种方法，函数呢？
  - typeof 数组不行 null 有错
  - instanceOf 不能用于原始类型
  - constructor 属性 如果改变对象原型就会出错
  - toString
- 对象包装器
  - 概念：原始数据类型
  - 特点
    - 提供原始数据类型的方法
    - 但并不是真正的构造函数
    - 可以自定义添加 prototype 上的值
- Symbol 是什么，有哪些用处
  - 概念：原始数据之一，创建方式
  - 特点
    - 不会被大多数方法遍历，但可以被完整复制
    - 任何两个 symbol 都不相等
  - 应用：
    - 隐藏属性，比如 react 的$$typeof
    - 部分特殊内置方法，比如迭代器
- 迭代器是什么，如何创建，怎么使用
- 怎么把一个类数组对象转为数组
- 怎么创建一个指定大小的空数组
  - new Array,Array.from
- Map 和 Set 是什么，有什么特点
  - 概念
  - 形式
  - 特点
    - 哈希表特点 O(1)读写查
    - 不重复
- 对象怎么配置一个属性（比如可读、可写）
- 箭头函数有哪些限制
- **闭包是什么，怎么产生的，有什么用，利弊**
  - 概念：闭包的定义
  - 出现场景
    - 嵌套函数
    - 回调函数
    - 立即调用函数
  - 使用场景
    - 保存和保护
  - 影响：内存泄漏
    - 内存泄漏定义
    - 内存泄漏出现场景
      - 全局变量
      - 定时器引用的对象
      - 引用但销毁的 dom 元素
      - 闭包
    - 解决方案
      - 减少闭包
      - 清除闭包变量
        - weakMap，key 为闭包函数，value 为闭包变量
      - 及时清除监听器
  - 产生原理
    - 执行上下文
- **作用域和作用域链是什么**
  - 作用域：
    - 概念：变量的可见情况
    - 产生：定义位置
    - 性质：静态
  - 作用域链
    - 概念：作用域的链
    - 产生：作用域相互连接
    - 作用：变量查找的依据
  - 和执行上下文的关系：
    - 区别：
      - 静态和动态
      - 产生时机
    - 联系：
      - 执行过程的变量查找符合作用域
- **执行上下文是什么，和作用域的区别，有哪些内容**
  - 概念：执行一段代码时的运行环境
  - 来源：全局和函数
  - 产生和应用时机
  - 结构：
    - 变量环境
      - 编译阶段将变量提升的变量声明
      - 执行阶段对变量赋值
    - 词法环境
      - 结构：栈
      - 存放块级作用域变量，每个块是栈的一项
  - 功能
    - 执行的变量查找依据：
      - 词法环境从上到下->变量环境->外部执行上下文
    - 作为函数的执行环境，影响 this
    - 提供闭包
- 块级作用域
  - 概念：
  - 产生：const 和 let
  - 性质：以块为边界
  - 相对的：变量提升作用域
    - 产生：var 和 function
      - 变量提升
        - 概念：编译阶段会先声明执行上下文内的变量和函数，执行阶段赋值
        - 效果：undefined
        - 影响：变量销毁和回收、提前使用的 undefined
    - 坏处：
  - 解决的问题
    - 及时销毁
    - 块内部生效
    - 作用域死区
- **this 是什么，有什么用，怎么指定 this 的指向？**
  - 概念：this 是函数执行环境的引用
  - 性质
    - 动态
    - 指代某个环境
  - 用处：
    - （个人理解）访问不属于自己上下文内，并且制定其他上下文中的变量
    - 构造函数
  - 应用场景
    - 对象属性
    - 构造函数和类
  - 取值
    - 全局使用
    - 普通函数
    - 构造函数
    - 对象方法
  - 绑定 this
    - 方法
      - new
      - callbindapply
      - 对象
      - 默认
    - 优先级：如上顺序
- new 的执行过程？
- **原型链是什么**
  - 原型：
    - 定义：两个方面
      - 所有对象：`__proto__`
      - 所有函数：prototype
    - 作用：属性和方法的链式访问，模拟面向对象的继承
  - 原型链
    - 定义：原型组成的链
    - 举例
- js 的继承方式
- **Promise 的功能，解决的问题，怎么实现的，怎么使用，特点，有哪些 api**
  - 概念：
  - 解决问题
    - 回调地狱
  - 解决方式
    - 延迟绑定
    - 返回值穿透
    - 错误冒泡
  - 性质
    - 三种状态
    - exector
    - resolve 和 reject
  - 使用
  - api
- async/await 的原理（协程），使用
  - 基本使用
  - 协程
- 模块化的发展历程
  - 全局函数
  - IIFE
  - namespace
  - AMD UMD
  - cjs
  - CMD
  - esm
- **commonjs 和 es6 module 的不同**
  - 不同
    - 静态和动态
    - 浅拷贝和引用
  - 相同
- Proxy 和 Reflect 是啥
- 事件循环，怎么实现的异步任务，宏任务和微任务？
  - 概念：
    - 事件循环是以浏览器为宿主环境实现的事件调度
    - 相关结构
      - 调用栈
      - 任务队列
      - webapi
  - 为什么需要
    - 异步任务非阻塞
    - 循环执行任务
  - 宏任务和微任务
    - 分类，如何产生的
    - 性质
    - 关系
- js 的内存管理、垃圾回收方式
- dom 树概述，dom 节点的概念（七种节点）
  - 节点：Element、Comment、DocumentType、Text 等
- dom 事件流？
- 事件对象是什么，怎么产生的，有什么用，自定义事件是什么。浏览器的事件模型
- 浏览器默认事件有哪些，怎么阻止
- 怎么封装一个 ajax（xhr 的用法）
  - open/send/onload/onerror
- 怎么使用 fetch
- 防抖和节流怎么实现
- webcomponents 是啥
- shadowdom 是啥
- 一个 HTML 页面的生命周期
  - readystate:interactive
  - readystate:loading
  - DOMContentLoaded
  - img onload
  - readystate:complete
  - window.onload
- ArrayBuffer 是什么，有什么用
- Blob 和 File 是什么，有什么用
- Generator 相关
- H5 history api

# 网络

- URL 和 URI 是什么
- 同源策略，跨域解决方案
  - 什么是跨域
  - 什么是同源策略
    - 概念
    - 同源条件
    - 不同源的限制
  - 为什么有跨域限制
    - 安全考虑
  - 怎么解决跨域
    - CORS
      - 概念
      - 请求分类
        - 简单请求
          - 定义
          - 处理方式：
            - origin
            - access-allow
        - 复杂请求
          - 定义
          - 处理方式
            - 预检
            - access-allow
    - JSONP
      - 原理：script 跨域请求
      - 实现
    - 代理
      - 原理
      - 实现：
        - http-proxy-middleware
        - devServer
- OSI7 层网络模型、TCP/IP4 层模型，5 层模型
- session、token、cookie 是什么，有什么特点和区别
  - cookie
    - 概念：一小段数据
    - 作用：获取用户身份信息
    - 属性
      - httponly
      - samesite
        - 跨站的概念
        - 三个取值及效果
          - lax
          - strict
          - none
        - 举例
          - 第三方 cookie
          - csrf 攻击
      - domain
      - secure
      - expires
    - 跨域问题
      - cors 控制是否发送 cookie
      - xhr 和 fetch 也可以控制
    - js 读写 cookie
  - session
    - 概念
    - 和 cookie 的区别
  - token
    - 概念
    - jwt
      - 本质：base64 格式的 json 对象
      - 优缺点
      - 使用方式
      - 结构
        - header
        - payload
        - signature
      - 防篡改
- HTTP 的基本特点
  - 无状态
  - 一收一发
  - 基于 tcp
  - 数据类型丰富
- HTTP 的请求和响应报文结构
- HTTP 的常见字段
  - 四类字段
    - 请求
      - Accept 相关
      - User-Agent
      - Cookie
    - 响应
      - Date
      - Last-Modified、Etag
    - 通用
      - Connection
      - Upgrade
    - 实体
      - Content-Encoding、Type、Language、Length
      - Content-Type 的 multipart/form-data 在请求体中的格式是什么
- HTTP 的方法有哪些
  - get head post put delete options
- **HTTP 状态码**
  - 101
  - 200
  - 301 302 304
  - 400 401 403 404 405 408 413 414 429
  - 500 502 504 503
- HTTPS 是什么，怎么保证安全，**握手过程**？
  - https 概念
    - 增加 tls 层
    - 增加 tls 握手
    - 数字证书
  - https 防范目标和方式
    - 窃听风险：混合加密
    - 篡改风险：数字签名（指纹算法）
    - 冒充风险：数字证书
  - https 握手
    - 步骤
      - client hello（client random、加密套件、算法）
      - server hello（server random、证书、选择的加密算法）
      - client done（pre-master，生成 screct，公钥加密报文）
      - server done（收到 pre-master，生成 screct，告知客户端握手完成）
- **HTTP1.0 1.1 2.0 3.0 都有哪些变化**
  - 1.0
    - 基本头
    - 基本缓存
    - 状态码
    - 问题：短连接、队头阻塞
  - 1.1
    - 长连接
    - 并发 tcp 连接
    - 更多缓存头
    - 新增请求方法
    - 问题：队头阻塞
  - 2.0
    - 二进制协议
    - 帧和流
    - 多路复用
    - 请求优先级
    - 服务端推送
    - 头部压缩（HPACK 算法，三个部分，静态表存储 key、哈夫曼编码压缩 value，动态表存储剩余）
    - 一个 tcp 连接
    - 问题：依赖 tcp，tcp 的队头阻塞
  - 3.0
    - 解决 http2 的问题：tcp 队头阻塞
    - 基于 udp 连接
    - quic 协议
    - 连接更快
    - 连接迁移不中断
    - 独立数据流
- HTTP 缓存，有哪些字段，缓存存放在本地的位置
  - 概念：根据一些头信息保存指定资源
  - 分类
    - 强缓存
    - 协商缓存
  - 控制字段
    - Cache-Control
      - max-age
      - no-cache
      - public、private
    - Last Modified & If-Modified-Since
    - Etag & If-None-Match
- DNS 是啥，怎么查询的
- CDN 是啥，有什么用
- UDP 协议的特点、应用、报文结构，和 TCP 的区别
  - 特点
    - 无连接
    - 一对多、多对一、多对多
    - 不可靠
    - 高效
  - 应用
    - 时效性强的连接
  - 报文结构
    - 源端口、目标端口
    - 报文长度
    - 检验和
    - 报文体
    - 8 个字节
- TCP 的特点
  - 面向连接
  - 一对一传输
  - 字节流
  - 可靠传输
  - 拥塞控制
- TCP 的报文段结构
  - 16 位源端口、16 位目的端口
  - 32 位 seq 和 ack
  - 6 个标志位
  - 16 位窗口大小
  - 16 位检验和
  - 16 位紧急指针
  - 保留的选项字段
  - 通常是 20 个字节（不包括选项）
- **TCP 的三次握手四次挥手**
  - 三次握手
    - 全过程
      - seq 和 ack
        - seq=x
        - ack=x+1，seq=y
        - ack=y+1，seq=x+1
    - 为什么三次，不是两次
      - 防止历史连接初始化
      - 保证 seq 和 ack 的交换
      - 防止浪费资源
  - 四次挥手
    - 全过程
      - FIN_WAIT1
      - CLOSE_WAIT
      - FIN_WAIT2
      - LAST_ACK
      - TIME_WAIT
    - 为什么四次
      - 可能是三次：ACK 延迟发送+没有数据
    - 为什么等待 2 个 MSL
- TCP 的可靠数据传输实现
  - 重传机制
    - 超时重传
      - 初始时间确定：测算和>2RTT
      - 超时加倍
    - 快速重传
      - 为什么是 3 个冗余 ack
- TCP 的流量控制实现
  - 滑动窗口
    - 发送方：四个部分
    - 接收方：三个部分
  - 流量控制的流程
    - 基本流程：收发
    - 收缩的流程：接收窗口变小，通知发送窗口变小
- TCP 的拥塞控制
  - 概念：
    - 处理丢包、超时等行为
    - 和流量控制的异同
      - 同：都是控制发送速度，cwnd 和 rwnd
      - 异：主要控制重传
  - 单位：MSS/RTT ，即一次收发时间内发送多少个最大报文段长度
  - 处理方式
    - 慢启动
    - 超时->拥塞避免
    - 冗余 ack->快速恢复
- IP 协议中的子网掩码和前缀是什么
- 特殊的 IP 地址
  - IP 全 0 和全 1（源地址、广播地址）
  - 主机号全 0：标识本子网
  - 主机号全 1：标识全部主机
- TTL 的作用
  - 防止无限转发
  - 丢弃数据包时向源主机发送通知帮助确定故障位置
- 链路层有什么作用
- **从浏览器输入 url 到显示页面的过程**
  - url 解析
  - 检查缓存（资源缓存）
  - dns 解析（检查客户端 dns 缓存、本地 dns 服务器缓存）
  - 获取 mac 地址
  - 从上到下封装报文
  - 发送到服务器
  - 建立 tcp 连接
  - https 握手
  - 发送 httpget 请求
  - 响应 html
  - 根据 http 头缓存资源
  - 浏览器网络进程交给渲染进程
  - 解析 html
  - 构建 dom 树、cssom
  - 构建布局树
  - layer
  - paint
  - 栅格化
  - 合成
  - 显示
- CSP 是什么，怎么开启
- XSS 攻击和防范
  - 概念
  - 基本原理：执行脚本窃取数据
  - 三种类型
    - 反射型
    - dom 型
    - 存储型
  - 防范
    - httponly
    - 不信任用户输入（过滤输入）
    - 不使用拼接字符串形成 html
    - 转码输出，html 转码和 js 转码
- CSRF 攻击和防范
  - 概念
  - 基本原理：模拟用户发起请求
  - 方式：
    - 诱导登录假网站，携带 cookie 发送请求
      - get：使用图片
      - post：构造表单
  - 防范
    - cookie samsite
    - Referer 头
    - 验证码
- DDos 攻击
  - SYN 攻击
    - 方式：大量发送链接请求，占满半连接队列
    - 防范：增大队列，或让半连接队列满时也可以建立连接
  - HTTP Flood、UDP Flood
    - 防范思路：增大带宽、限制速率等

# 操作系统

- 进程
  - 进程出现的原因
  - 进程的定义
  - 进程的结构
    - 程序段
    - 数据段
    - PCB
      - 包含信息
        - 标识符
        - 当前进程状态
        - 优先级
        - 资源
  - 进程的特点
    - 动态性
    - 并发性
    - 独立性
    - 异步性
  - 进程的状态
    - 就绪
    - 执行
    - 阻塞（暂停）
    - 创建和销毁
    - 挂起（没有占用物理内存）
      - 就绪挂起
      - 阻塞挂起
  - 进程调度算法
    - FCFS
    - 最短作业优先
    - 时间片轮转
    - 最高优先级调度
    - 多级反馈队列
  - 进程通信的手段
    - 管道、消息队列、共享内存、信号量、信号
  - 进程同步
    - 方式
      - 同步锁
        - 忙等待和非忙等待锁
      - 信号量
        - 基本概念
          - 临界区
          - 临界资源
          - 信号量
        - 常见问题
          - 生产者消费者
          - 哲学家进餐
          - 读者写者
- 线程
  - 定义：CPU 的基本调度单位
  - 特点
  - 实现
    - 用户线程
    - 内核线程
    - 轻量级线程
  - 进程和线程区别
    - 定义
    - 切换开销
    - 资源
- 死锁
  - 必要条件
    - 互斥
    - 请求和保持
    - 不可抢占
    - 循环等待
- 内存管理
  - 虚拟内存
    - 作用：
      - 增大内存大小
      - 防止访问冲突
      - 操作更加安全
  - 管理方式
    - 分页
    - 分段
    - 段页：先分段再分页
  - 页面置换算法
    - 原因：缺页中断（CPU 访问的页面不在物理内存，从磁盘调入）
    - 最佳页面置换（未来最长时间不访问的页面剔除）
    - 先进先出
    - LRU
    - 时钟

# 浏览器

- 浏览器中的主要进程和线程有哪些
  - 进程：
    - 渲染进程
      - gui 渲染线程
      - js 线程
      - 定时器
      - 异步任务
      - 事件处理
    - 网络进程
    - 主进程
    - 插件进程
    - gpu 进程
  - 新式架构
    - 多进程+服务，把 ui、storage、file 等放到各个服务内
- **浏览器渲染页面的过程**
- gpu 加速的原理
- **重绘重排，触发原因，优化**
- 解释和编译型语言
- v8 怎么执行一段 js 代码的
  - 过程
    - 词法分析（分词）
    - 语法分析（创建 AST）
    - 生成字节码
    - 生成机器码
    - 执行机器码
  - 工具
    - 解释器：ast->字节码
    - 编译器：字节码->机器码
    - 即时编译：部分热点代码提前编译

# webpack

概述，功能，为什么需要 webpack
核心概念

- chunk
  - 三种 chunk
  - hash
- module
- bundle
- dependence
- plugin
- loader

配置：

- 配置文件
  - 导出的值的不同：
    - 对象
    - 函数
    - 数组
  - 多个配置文件
    - webpack.common.js/webpack.development.js/webpack.production.js
    - merge 函数合并配置
    - webpack --config 选定配置文件
- 基本配置项及其配置方式，比如 entry 的多种配置方式及其效果
  - entry
    - 四种形式
      - 对象
        - 配置项：import、dependOn、runtime、filename
      - 数组
      - 函数：make 阶段调用
      - 字符串
  - output
    - 输出 hash 和缓存
  - module
    - rules 配置 loader
  - resolve
  - plugins
  - devServer
  - 其他：optimitize、target、cache

优化：

- 开发环境
  - 构建速度
    - 减小解析范围
      - loader
      - resolve
      - 极端：noParse/externals
    - 多进程
      - thread-loader
      - 压缩过程的并行
    - 关闭某些生产环境的优化
      - splitChunk
      - minisize
      - useExports
    - cache
    - devtools
- 生产环境
  - 构建产物
    - 压缩代码
      - terserwebpackplugin-压缩 js
      - MiniCssExtractPlugin-分离并压缩 css
    - tree-shaking
      - 效果和目的
      - 开启方式
      - 基本原理
      - 注意事项
        - 减少导入赋值
        - 使用 es6 的库
        - 禁止 babel 编译 import
    - 代码分割
      - 三种方式
        - 多入口手动分离
        - 动态导入
        - splitChunk
          - `'all'`配置在所有 chunk 之间共享模块
          - maxSize 和 minSize
          - cacheGroup
- 其他
  - http 缓存
    - contenthash
    - 利用 splitChunk 对不经常变动的模块分包
      - runtime
      - 第三方库单独打包

原理：

- 一些核心概念，比如 module、chunk、compiler、compilation、hook、dependencies、chunkGraph、moduleGraph
- 基本工作流程，三步的具体工作内容
  - 初始化
    - 收集参数
    - 创建 compiler 对象
    - 启动编译流程
  - 构建
    - 从入口进入
    - 调用 loader 翻译模块，生成模块 ast
    - 解析导入导出，递归生成 module
  - 生成
    - 创建 chunkgraph
    - 从入口开始递归生成各个 chunk
    - 生成代码，输出文件
- hook 机制，hook 是什么，怎么用 hook，webpack 是怎么用 hook 的，有什么用，我们能用到什么
- loader：原理，以及自己编写的 loader 的原理，使用了哪些 api 和上下文
- plugin：原理，自己编写 plugin 的原理，使用了哪些 hook 和 api
- hmr
  - 概念，用处
  - 使用：hot，module.hot.accept
  - fast refresh 两者区别
    - 使用上的区别
    - 原理上的区别
  - 原理
    - 注入 runtime
    - 建立 浏览器-devserver ws 连接
    - 文件变化 -> hash 事件 -> 浏览器请求 manifest
    - devserver 返回 manifest -> 浏览器请求对应的更新文件 -> express 返回该文件
    - 执行 module.hot.accept 更新

使用经验：

- 如何配置 react 脚手架
- webpack.config.ts
- babel 配置，解析 ts 和 react
- 引入 hmr 和 fastrefresh
- 配置 css module

# 工程化

- node 相关
  - package.json 的作用，几个关键字段
    - peerDependencies，dependencies、devDependencies
  - package-lock 作用
  - npm
    - npm 包版本号
      - `[major,minor,patch]`
      - `^`和`~`
    - npm install 全过程
      - 检查是否安装
      - 解析 package 和 package-lock
      - 搜索远程库，下载包，缓存，解压
      - 扁平化解压
    - npm run 全过程
      - 安装依赖时安装可执行文件到 bin
      - 软链接
- npm/yarn/pnpm
  - yarn 的特点
    - 并行下载
    - 安全检查
  - pnpm 的特点
    - 硬链接依赖
    - 更新时只更新最小内容
    - 速度快
      - 解析和下载过程连续，加快速度
    - 非扁平 node_modules
      - 根 store 存储所有库的所有版本
      - .pnpm 根据项目需要扁平化硬链接
      - node_modules 的其他库都是对.pnpm 内的软连接
    - 局限性：
      - 如果修改 store 可能影响所有项目
      - 兼容性不佳
- Babel
- Vite
  - 特点
    - 依赖和源码，依赖预构建
      - esbuild，go 编写
    - 源码直接引入，利用浏览器 module
    - 开发环境强缓存
    - rollup 打包
- ESlint
  - 配置
    - extends 加载预设，plugins 使用插件。
- git
  - 基本概念
    - 工作区、暂存区、版本库
    - 分支
    - HEAD 指针
  - 常用命令
    - 创建切换分支
    - git log 查看历史 commitid
    - git reset --hard HEAD^回退 commit
    - git stash
    - git cherry-pick commitid
    - push/pull/fetch
    - git tag
  - 工作流
    - git flow
      - 长期分支：master 和 develop
      - 临时分支：feature/hotfix/release
    - github flow
      - master 创建 feature
      - feature 提 pr 到 master
    - gitlab flow
    - gitflow flow
      - 标准五分支，master/release/fix/feature/develop
- 其他模块化内容
  - 循环加载
    - cjs：循环加载只输出第一次执行，之后遇见不执行
    - esm：差不多，import 不会进入已经解析过的模块
  - 项目中问题：循环依赖导致使用在定义之前
    - 解决方案：统一导入再统一导出，统一导入时按照合理顺序
- MVVM/MVC
  - MVC
    - model：数据
    - view：展示的界面
    - controller：后端代码
    - 单向
  - MVVM
    - model：数据
    - view：视图
    - viewModel：模型，连接视图和数据，双向绑定

# 优化

- 优化方式
  - **网络优化**
    - 网络请求优化
      - http 优化
        - 1.1 版本优化
          - 减少资源数量
          - 减少请求数量
          - 充分利用缓存
          - 减小请求大小
          - 细分域名
        - 2.0 版本优化
          - 不要关心请求数量
          - 减小请求大小，轻量，细粒度，增强缓存
      - 使用 http2.0/3.0
      - dns 预解析
      - 预连接
      - cdn
      - http 报文体压缩
      - js 请求的防抖节流
    - http 缓存优化
      - webpack 配置缓存的方式
      - 服务端配置合理的缓存
  - **静态资源优化**
    - 预加载
      - 手动添加 preload、prefetch 库
      - webpack 动态导入
      - js 预加载
      - react-loadable/React.lazy
    - 懒加载
      - 判断进入可视区域
      - 列表懒加载
    - 图片
      - 小图合并
      - 图片压缩
      - 采用 webp 格式
      - 媒体查询、响应式图片采用低分辨率
      - jpg 和 png
        - jpg：有损压缩，体积更小，不支持透明度
        - png：无损压缩，质量更高
    - 缓存
      - http 缓存
      - localstorage
      - service worker
  - **运行时优化（代码优化）**
    - js
      - 减少 dom 操作、集中 dom 操作
      - script 标签位置
      - 代码质量优化，更优的算法、数据结构
      - 非阻塞渲染，对于高性能开销的任务做时间分片、WebWorker 等
    - css
      - 不使用@import
      - css 代码性能
        - 减少缩写
        - 少用浮动、绝对定位
        - 减少重绘重排
      - css 选择器性能
        - 少用低性能选择器
        - 少用通配符
    - 减少重绘重排
      - 不用 table 布局，用弹性布局
      - 改变 class 而不是 style
      - css 动画
      - gpu 加速，合理利用 gpu 能力，比如 transform 代替位移
      - 减少影响文档流
    - webpack 优化
      - 开发环境
      - 生产环境
    - react 优化
      - 减少 render 次数
        - 避免不必要渲染
          - memo
          - 给子元素的 props 维持单一引用
          - useRef 代替部分 useState
          - 使用 css 替代条件渲染
      - 降低 render 消耗
        - 分离组件，减小单组件渲染开销
        - useMemo、useCallback 保存高消耗
- 性能指标
  - RAIL 性能模型
  - web 用户指标
    - FP
    - FCP
    - FMP
    - **LCP**
    - TTI
    - **FID**
    - **CLS**
  - 检测方式
    - PerformanceEntry
    - web-vitals 库
- 性能检测工具
  - lighthouse
  - chrome devtools

# react 源码

- 函数组件和类组件的区别
  - 组件本质（函数和类）
  - 保存数据的方式
  - 生命周期
  - React element 的获取
- 类组件的生命周期
  - 挂载
    - constructor -> getDerivedStateFromProps -> render -> componentDidMount
  - 更新
    - gdsf -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> commit -> componentDidUpdate
  - 废弃的声明周期，为什么？
- React 事件系统
  - 概念：
    - React 自己创建的
    - 为什么？磨平浏览器差异，配合虚拟 dom，模拟事件
  - 三个部分
    - 事件合成
      - 概念：事件对象是自己合成的
      - 事件插件
        - 概念
        - 功能
          - 注册事件，保存当前类型事件的合成的 dom 事件列表
          - 当事件触发时：合成事件对象，创建 listener 放入执行队列
    - 事件绑定
      - createRoot 绑定所有事件
      - 绑定的 listener 实际上是不同事件优先级的 dispatchEvent
    - 事件触发
      - 事件触发
        - 根 dom 捕获
        - dispatchEvent
        - 通过事件插件合成事件对象和 listener 对象、dispatchQueue
      - 事件收集
        - 找到事件触发的那个 fiber
        - 从下向上收集事件，获取每个 fiber 上的事件 props，收集同名事件
      - 事件执行
        - 根据事件类型确定顺序
          - 如果是捕获就倒序
          - 如果是冒泡就正序
- React fiber
  - 概念：虚拟 dom
  - 引入原因
    - 方便控制
    - 减小阻塞，中断渲染
      - 把更新过程拆成每个 fiber，需要可以随时中断 render。commit 不可中断
    - 双缓冲树 复用
  - fiber 结构
    - 属性
      - React element 相关属性
      - fiber 树的连接属性
      - 组件属性
      - 副作用相关
      - 优先级
      - alternate
  - 双缓冲树
- React 异步调度
  - 目的：解决阻塞
  - 方式
    - 异步调度
      - 通过 messageChannel 将任务放到空闲时间执行
    - 时间分片
      - scheduler
      - 五个优先级
      - taskQueue 和 timerQueue
      - 任务被拆散到每个时间片空闲执行
      - 使用 messageChannel 调度 workLoop
      - workLoop 中断重新注册任务到下个时间片
      - 中断条件
        - isInputPending
        - 任务已经执行时间 >= 一帧剩余时间
    - 渲染中断
      - render workLoopConcurrent
- React 调和过程
  - render
    - beginwork
      - 功能
      - Reconciler
      - diff 算法
        - 单节点
        - 多节点（数组类型）
          - 两轮遍历
    - completeWork
      - 功能
  - commit
    - 每个阶段及其功能
  - flags 机制
    - 标记时机
    - subtreeFlags
    - 消费时机
    - 代替 EffectList
- React 更新流程
- React hooks 原理
  - hook 和 fiber 的关系
    - fiber.memoizedState 保存 hook 链表
  - hook 对象
    - 创建 hook
      - mountHook
      - hook.memorizedState：核心存储位置
      - hook.next：核心链表
    - 更新 hook
      - updateHook
      - 取 hook.next 复用
  - useState
    - update：更新对象
      - updateQueue:update 链表
      - baseQueue：低优先级更新
    - mountState：初始化 updateQueue 和 dispatch
    - updateState：执行 updateQueue 和 baseQueue
  - useEffect
    - 执行时机：before mutation 异步启动
    - effect 链表
- React 并发渲染
  - createRoot（FiberRoot）
  - scheduler
  - 可中断 render
- React 优先级机制
  - 事件优先级
    - DiscreteEventPriority ContinuousEventPriority DefaultEventPriority IdleEventPriority
  - lane 优先级
    - SyncLane InputContinuousLane DefaultLane IdleLane
  - scheduler 优先级
    - ImmediateSchedulerPriority UserBlockingSchedulerPriority NormalSchedulerPriority IdleSchedulerPriority

# React（使用）

- React 优化
  - 核心思想：降低渲染成本，或者尽量避免渲染
- React 高阶组件是什么，怎么用
  - 功能
    - 强化 props
    - 渲染拦截
    - 外层包装
- React18 带来了哪些更新？
  - concurrent 模式
  - Transition
  - 新的 hooks
    - useId：用于生成唯一 id，这个 id 在服务端和客户端渲染时生成的相同，可以保证水合过程的稳定
    - useSyncExternalStore：可以从外部获取一个状态
    - useInsertionEffect：为了解决 CSS-in-JS 库解决在渲染中注入样式的性能问题，在 before mutation 阶段调用
  - Suspense 的更新（未完全实现）
    - 可以使用除了 lazy 之外的部分实现
  - 自动批量更新
  - ssr api 的更新
- React 错误边界
- React-Router 简单原理，基本实现原理，两种路由方式的区别，以及基本使用
- React 状态管理库：
  - flux 理念
    - action -> dispatcher -> store -> view -> action -> dispatcher
  - Redux：基本理念、基本组成部分及其实现、常用的几个 api 和实现，怎么和 react 结合的，具体使用
    - 基本理念
      - 单向数据流
      - 数据不可变（state）
    - 基本结构
      - store
      - state
      - reducer
      - dispatch
      - action（为什么需要 action？）
      - subscriber
    - middleware 机制
    - react-redux
      - react 和 redux 连接的方式
        - provider 添加订阅，状态改变触发 listeners
        - useSelector 获取最新 state
        - useSyncExternalStore
        - connect
    - 现代使用
      - createSlice
  - Recoil：几个特点、atom 和 selector 两个核心概念、和 redux 的不同
    - 基本特点
      - 状态原子化
      - 有向图 数据流
      - 对 Concurrentmode 的支持
    - 和 redux 的差别
      - 状态更细分
      - 状态连接更随意
      - 轻量
      - 对 Concurrent 支持好
      - 使用层面：更简单，对 ts 支持更好

# React Native

- 基本使用
  - 页面和导航
    - 特点：页面不会被卸载
  - 动画
    - Animated
      - Animated 组件
      - Animated.timing
    - LayoutAnimation
  - 调用原生
    - 直接调用原生模块
    - 调用原生方法
- 性能
  - 不同方面
    - js 帧率
    - ui 帧率
    - 产物
      - RAM Bundles 和内联引用优化
        - 基本原理：RAM 和 require 分别是什么
        - File RAM bundle 和 Indexed RAM Bundle
        - 和 import()的区别
    - 长列表
      - FlatList 和 SectionList
      - 优化方式（props 传入）
      - 长列表的基本原理
    - React 性能
  - 指标和测量方式
    - 首屏：js bundle 资源下载及解压耗时 + RN 视图创建耗时 + RN 资源加载耗时 + js bridge 及应用启动耗时 + 首屏视图渲染耗时
    - 帧率
    - TTI、FID、FMP、FCP
  - 优化方式
    - 渲染
    - bundle
    - 预加载预请求
    - 缓存
    - 帧数优化
    - 内存
    - 网络请求
- 组件
  - 列表
    - 四种列表
    - 虚拟列表实现原理和特性
      - 只渲染可视
      - 节点回收和复用
      - 异步加载和渲染
      - 渲染优先级，滚动方向
    - 优化
      - maxToRenderPerBatch 和 updateCellsBatchingPeriod 控制批处理
      - initialNumToRender
      - windowSize
      - ListItem 优化
        - item 组件简单化
        - 轻量，不用大图
        - memo
        - getItemLayout
        - key
- 原理
  - 旧版架构
    - 关键部分
      - js 代码
      - js 引擎
      - bridge
      - native
    - 渲染
      - 渲染线程
        - ui 线程
        - js 线程
        - shadow 线程
      - 三颗渲染树
        - fibertree
        - shadowtree
        - 原生 tree
      - 渲染过程
    - 通信
      - js 调 native 方法
      - native 调 js 方法
      - 序列化
    - 其他
      - bundle：一个入口是一个 bundle
      - rn 启动流程
  - 新版架构
    - JSI
    - Fabric
    - Turbo Modules
- 其他
  - 跨端差异 ios和安卓
    - 表现不一致：多做测试
    - 样式有差别：多调整，设计两套样式
    - api不同：根据文档调整，比如FlatList，多做测试

# 深层思考问题

- 状态管理库
  - 为什么 redux 要这么设计，需要 action？
  - 选择状态管理库的依据？
    - 使用：减小心智负担
      - 使用简单
      - 对 ts 支持好，对 react hook 支持好
      - 业内通用解决方案
      - 维护程度、npm 下载量
  - 假如让你设计一个状态管理库，需要注意哪些方面
    - 数据的存储方式
    - 怎么触发数据的更新
      - redux：dispatch
      - mobx：直接修改
      - recoil/jotai：hooks
    - 状态更新怎么反映到 react 更新
      - props
      - context
      - useSyncExternalStore
    - 状态和派生状态
      - selector
    - 和 react 配合时的优化，避免无谓的更新？
  - 为什么选用 recoil 而不是其他
    - 项目实际情况
      - 组件复用比较少，需要共享的数据比较少
      - 组件状态零碎，顶层的状态有些组件需要，有些不需要
    - 比较
      - redux 的优劣
        - 模板代码太多，toolkit 治标不治本
        - 对类型支持不够好
        - 状态杂糅
      - mobx、jotai、zustand 的优劣
        - mobx：没有使用 hooks、响应式逻辑不符合 react 单向数据流，不好调试
        - jotai、zustand：维护一般，使用者少
      - recoil 的优势
        - 状态原子化，方便控制和管理
        - 模板代码少
        - 对类型支持好，hooks 支持好
        - facebook 官方，质量保证
- canvas、konva
- 组件库的设计
  - 整体设计
    - 每个组件的独立性要强，维护自己的状态，低耦合
    - 通用状态或配置可以通过 context 下发，比如国际化、rtl、主题等
    - 组件的 props 作为配置存在，默认 props、传入的 props、全局 context 合并为组件配置
      - props 类型
        - 通用的：classname、style、children
    - 样式
      - 使用预处理器变量、函数、mixin 等特性。
        - 比如，对于 button 组件，先维护一个各种变量的组件，比如名字为`@btn-size-mini-border-width`；然后在实际的样式文件中，通过 less 的 mixin，传入不同的值，类似模板字符串的形式使用样式`~'@{btn-@{type}-color-bg}'`。连字符的中间项可以替换，比如这里`mini`对应的值可能是 1px，那么假如把 mini 换成 large，那就是大按钮的样式，值可能为 2px。总之只需要预设好样式，然后在 less 中使用 mixin 填入对应的字符即可。样式和具体组件还需要借助 classname 库配合
    - 父子组件
      - 数据传递
        - cloneElement 注入 props
        - provider 下发深层 context
        - forwardRef
  - 具体组件设计
    - 表单：参考https://github.com/varHarrie/varharrie.github.io/issues/28。
      表单的设计核心思想就是部分复杂组件的设计方案，即：
      - 组件间的嵌套和划分，比如用 cloneElement 传入 props
      - 数据的存储和下发，比如表单组件内通过 FormStore 存储数据和存储 listeners，然后通过 context 下发 FormStore
      - 基本通信方式：发布订阅，当每个元素状态改变时，发布到顶层修改状态
  - 文档

# 设计模式

- 工厂模式
  - 简单工厂
  - 工厂
    - 区别：简单工厂扩展需要修改内部代码（ifelse），工厂模式可以通过继承
  - 抽象工厂
- 单例模式
  - js 实现：Class.instance 获取该类的实例
  - 应用：全局 Modal
- 装饰器
  - 本质：函数
- 原型
- 适配器
- 代理
  - 事件代理：即 js 的事件委托
  - 虚拟代理：比如图片加载之前用 image 对象当占位符
  - 缓存代理：缓存函数，比如存储函数计算结果
- 策略
  - 策略模式：封装 ifelse
- 观察者和发布订阅
  - 两者区别：观察者模式中订阅者可获取发布者实例，发布定于模式则直接传递参数
  - 实现：可以通过 map

# 项目

- 超管
  - 难点
    - canvas
      - 使用 konva 的一个问题：事件委托的实现问题
        - 具体问题：实现实时地图和实时点位的功能，依赖冒泡，但是冒泡和 dom 中不一样
        - 个人尝试：
          - 嵌套
          - 包裹
          - 直接放在 layer 上：有其他事件
        - 解决方式：
          - 先查看官方文档：没有对事件流的讲解，只提到了冒泡这个东西，没说规则
          - github issues：没有相关的
          - 查看源码
            - 首先单独创建一个项目，调试源代码，搞清事件执行的关键函数
            - 搞清“parent”是啥：必须通过 add 手动添加，必须是 container
          - 解决：采用一个 container 包裹地图和点位，在 group 上监听
      - 地图的拖拽实现
        - 具体问题：地图的底图很大，不能全部显示，只能显示一部分，然后需要实现移动展示全部
        - 个人尝试
          - 使用整个 canvas 放底图：性能太差
          - 固定 canvas 大小，然后利用 translate 实现拖拽
        - 解决方式
          - 先单独创建项目自己尝试
          - 查阅一些资料和其他的解决方案，综合使用
        - 具体解决：
          - 实现拖拽效果，具体参考项目
          - 实现点位的可视区域绘制
          - 边界限制，防止移出可视区域
        - 拖拽效果的优化
          - 了解优化方式
          - 了解哪些是konva做的，哪些是我们需要做的
          - 优化
            - 分层
            - 可视区域绘制，缩小不绘制
            - 整合数据
          - 优化体现：performance面板
        - 业内实现
          - 其他优化方式：脏矩形、离屏渲染、预渲染、分块加载等
          - 地图实现方式：瓦片地图
    - 代码规范不易遵守，经常忘记：采用 eslint，自己编写 plugin
      - 编写 plugin
        - 方式：ast
        - 途径：官方文档
        - 发布：bnpm
        - 应用：组内使用，部门分享
        - 延伸：配置，可以自定义希望的格式，比如自定义 setState 的格式
    - 状态管理问题：调研多个状态管理库，调研公司内使用
      - 状态管理库
        - 基础思路：从聚合化到原子化，项目需要原子化
        - redux：模板代码多、类型支持一般、状态聚合
        - mobx
        - recoil
        - zustand、jotai
- 特团
  - 轮播图需求
    - 轮播图
      - 实现关键点
      - 基本原理
      - 滚动流程
      - 实现亮点
        - loopClonePerSide
        - onActiveItemScrollToNext
        - FlatList
      - 组件设计
        - api
          - props分类设置
            - 必须属性
            - 默认值
            - 错误props传入的报警和兜底
            - ref暴露方法，但把外部和内部调用分开
        - 其他方面
          - props风格统一
          - 尽可能多默认值
          - 类型设计好
          - 增加更多插槽（ReactNode props支持）
          - 独立性、纯粹性、扩展性
          - 内部优化
          - 样式和类名统一
    - 轮播图视频
      - 关键点：视频单实例
      - 实现思路
        - 视频固定，优缺点
        - 视频跟随，及时销毁，通过 onActiveItemScrollToNext提前销毁
  - 优化
    - 优化原因
    - 优化指标RCF
      - 测量方式
      - 优化前评分：C 3分，加载时间超过3000，有卡顿和闪烁情况
    - 优化方式
      - 首屏优化
        - 包体积优化
          - 删除大包
          - 优化tree-shaking
          - 引入插件优化导入
        - 分包
          - 分离Modal组件等大量不需要首屏加载的包
          - 分离视频组件，延迟加载
        - 渲染优化
          - 首页渲染分级
          - 商详页渲染分级，部分模块懒加载
        - 预加载，根据PV，从会场页预加载商详页
      - 问题优化
        - 闪烁：猜测是频繁状态更新，通过wydr，轮播组件自顶向下检查，找到问题是redux，替换为全局事件+animate
        - 吸顶卡顿
          - 分析过程，点击 -> 吸顶移动 -> 显示券列表 -> 显示二级tab
          - 分别只保留一个过程，确定卡顿来源是显示券列表
          - 通过Profiler工具分析发现执行大量ScrollView元素渲染
          - 更新为FlatList
      - 优化结果
        - 验证：线上RCF评分，测试包页面加载时间和包体积分析
        - 包体积从 3MB 降低到 1.5MB，首次加载的包体积仅有 900KB
        - 首屏加载速度从 3000ms 提升到 1000ms 左右，C 指标从 3 提升到 20

# 新知识

- Vite 和 Turbopack
  - 了解途径：React 周报、公司内部的周报、掘金社区
  - 学习方式
    - 先看官方文档
    - 再看社区内容，比如掘金、谷歌
    - 动手实践，尝试官方文档的描述
  - Turbopack
    - 特点和为什么快
      - 类似 webpack 的开发环境打包，但是能自动分析所需依赖
      - rust 编写，打包更快
      - swc 等工具，编译更快
      - 独特的函数级缓存，函数执行结果不会再执行
      - 按请求编译，需要什么编译什么
    - 使用
      - 目前只能在 nextjs 中尝试
  - Vite
  - Recoil
